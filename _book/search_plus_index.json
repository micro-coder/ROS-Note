{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction ROS学习记录ROS版本：Kinetic系统：Ubuntu16.04 "},"Chapter1/Introduction.html":{"url":"Chapter1/Introduction.html","title":"第一章 ROS基础搭建","keywords":"","body":"Chapter 1 Introduction 本章主要记录ROS的安装和配置过程 "},"Chapter1/ROS安装.html":{"url":"Chapter1/ROS安装.html","title":"第一篇 ROS安装","keywords":"","body":"第一篇 ROS 安装 在安装之前，先要配置好Ubuntu的系统环境 打开System Settings -> Software & updates -> ubuntu software，全部都勾选,如图所示: 更改源为中国科学技术大学的镜像源 (使用国内的Ubuntu镜像源下载速度会更快些)，如图所示: 添加 sources.list(添加镜像源：科大源)sudo sh -c '. /etc/lsb-release && echo \"deb http://mirrors.ustc.edu.cn/ros/ubuntu/ `lsb_release -cs` main\" > /etc/apt/sources.list.d/ros-latest.list' ⑴. 点击下图红框中的链接，进入： ⑵. 粘贴下图的命令Command即可。 添加 Keys(公钥是Ubuntu的一种安全机制，也是ROS安装不可缺少的一步，第1步勾选的目的就是这个)sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 执行系统更新，更新源列表, 确保获得的ROS软件是最新的sudo apt update sudo apt upgrade 安装ROS包 ROS中有很多函数库和工具，官网提供了四种默认的安装方式，当然也可以单独安装某个特定的软件包。这四种方式包括桌面完整版安装、桌面版安装，基础版安装、单独软件包安装。推荐安装桌面完整版安装（包含ROS、rqt、rviz、通用机器人函数库、2D/3D仿真器、导航以及2D/3D感知功能），如下： 安装Kinetic版本的ROS(desktop-full : 桌面完整版)sudo apt-get install ros-kinetic-desktop-full 如果你不想安装桌面完整版，你还可以尝试以下三种方式安装： 桌面版安装（包含ROS、rqt、rviz以及通用机器人函数库）sudo apt-get install ros-kinetic-desktop 基础版安装（包含ROS核心软件包、构建工具以及通信相关的程序库，无GUI工具）sudo apt-get install ros-kinetic-ros-base 单独软件包安装（这种安装方式在运行ROS缺少某些package依赖时会经常用到。你可以安装某个指定的ROS软件包,使用软件包名称替换掉下面的PACKAGE）sudo apt-get install ros-kinetic-PACKAGE 例如系统提示找不到slam-gmapping，你就可以：sudo apt-get install ros-kinetic-slam-gmapping 要查找可用的软件包，请运行：apt-cache search ros-kinetic "},"Chapter1/ROS配置.html":{"url":"Chapter1/ROS配置.html","title":"第二篇 ROS配置","keywords":"","body":"第二篇 ROS配置 ROS安装完成之后，我们还需要在自己电脑上对ROS进行一些参数的配置，使ROS能够正常工作。就像我们刚买到新手机一样，在开始使用之前，必须要做一些配置操作。 配置环境变量echo \"source /opt/ros/kinetic/setup.bash\" >> ~/.bashrc source ~/.bashrc 如果不配置，我们每打开新的终端terminal时，每次都要配置一次ROS的环境，不然ROS的命令不能正常使用。相反，将ROS环境变量添加到～/.bashrc文件中之后，我们每打开新的终端terminal时，系统每次都会自动把ROS环境变量配置好，ROS的命令就可以直接使用，很方便。 到目前为止，我们已经安装了运行核心ROS软件包所需的软件。为了创建和管理自己的ROS工作空间，我们还需要安装rosinstall工具，以及其依赖包：sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential rosinstall是ROS中一个独立的命令行工具包。通过一条命令就可以下载ROS的许多源代码。 初始化 rosdep sudo rosdep init 在使用ROS支持的工具或命令之前，需要初始化ROS。rosdep init会自动初始化ROS，并安装ROS运行必需的依赖文件。 更新 updaterosdep update 紧跟着就 update，更新此版本的ROS到最新的状态。并且不用sudo切换到管理员权限 至此，我们就完成了ROS的安装和配置工作，接下来就测试一下ROS能否正常工作吧。 首先启动ROS，运行 roscoreroscore 终端输出结果如图，就说明ROS能正常 启动： 然后运行ROS的吉祥物-小海龟，测试ROS的运行是否正常 重新打开一个新的终端，输入： rosrun turtlesim turtlesim_node 你就可以看到弹出一个新的窗口界面，一只小海龟出现在窗口里 　　　　　　 怎么操控这个小海龟呢？我们再重新打开一个终端，启动按键控制程序，输入命令： rosrun turtlesim turtle_teleop_key 接下来，我们运行在这个终端里，并通过键盘上的方向键，就可以控制小海龟的运动了。 至此，经过了上面的测试，ROS的安装、配置工作就已经全部完成了。 下面就可以正式开启ROS的学习之旅～～～ "},"Chapter1/小结.html":{"url":"Chapter1/小结.html","title":"小结篇","keywords":"","body":"Chpaer 1 小结 在第一章的学习过程中，我们主要是完成了ROS的安装工作，工欲善其事，必先利其器。在学习的过程中，也是遇到了一些问题，对于还没入门的我来说，有的问题反复出现，解决的时间也很长。在此记录下来，以备日后查看。 第一章遇到的问题大都跟网络有关系，挂vpn可能会解决问题 1. 执行命令 sudo rosdep init出错 问题如图所示：　　　　 解决方法：这个问题的原因是raw.githubusercontent.com域名解释被污染了（你懂的...）。解决方法是到ipaddress.com上查询raw.githubusercontent.com的ip地址，然后在ubuntu的/etc/hosts文件上面加入这条域名解释就行了sudo vim /etc/hosts 注：查询到的IP地址不一定是下图所示 　　 2. 执行命令 rosdep update出错 问题如图所示：　　　 解决方法：主要是网络访问不稳定，只有多来几次。或者换成手机热点多试几次。 "},"Chapter2/Introduction.html":{"url":"Chapter2/Introduction.html","title":"第二章 ROS学习基础","keywords":"","body":"Chapter 2 Introduction 本章开始正式学习ROS所用到的学习参考资料有：ROS-Academy-for-Beginners "},"Chapter2/安装ROS-Beginners教学包.html":{"url":"Chapter2/安装ROS-Beginners教学包.html","title":"第一篇 学习资料源码下载","keywords":"","body":"安装ROS-Academy-for-Beginners教学包 这是我找到的算是比较系统的学习ROS入门的资料，目前关于ROS基础的学习资料比较少，所以网上资料也比较零散。我参考的这份学习资料对于我这个还没入门的人来说，很珍贵。所以我基本上参考这份资料进行学习，并记录自己在学习过程中遇到的问题和解决方法。 下载git因为我们需要从github上下载源代码，所以需要先安装git工具。ubuntu系统一般会自带git。sudo apt install git 然后，创建一个文件夹,作为ROS的工作空间workspace，名称随意，我这里命名为tutorial_ws mkdir tutorial_ws 并且在tutorial_ws文件夹下再创建一个子文件夹，这个子文件夹的名称不是随意的了，必须为srccd tutorial_ws mkdir src 接下来克隆github上的教学包代码到本地的src文件夹里 cd tutorial_ws/src git clone https://github.com/DroidAITech/ROS-Academy-for-Beginners.git 教学代码包还需要一些依赖文件，所以接下来就安装依赖文件 cd tutorial_ws rosdep install --from-paths src --ignore-src --rosdistro=kinetic -y 注：以上命令很重要，缺少依赖将导致教学包无法正常编译和运行 在开始编译教学代码之前，还需要确保安装的gazebo版本在7.0及7.0以上 使用指令查看一下 gazebo -v 如果你的gazebo版本低于7.0，则需要升级(命令来自于gazebo官网) sudo sh -c 'echo \"deb http://packages.osrfoundation.org/gazebo/ubuntu-stable `lsb_release -cs` main\" > /etc/apt/sources.list.d/gazebo-stable.list' wget http://packages.osrfoundation.org/gazebo.key -O - | sudo apt-key add - sudo apt-get update sudo apt-get install gazebo7 注：最后一行命令最好还是下载 gazebo7，更高版本可能会有其他问题 准备工作已经完成了，现在可以编译教学代码了 cd ~/tutorial_ws catkin_make source ~/tutorial_ws/devel/setup.bash 注：每一次使用catkin_make编译完成后，必须使用 source 命令刷新一下工作空间的环境，否则可能找不到工作空间。 许多时候我们为了打开终端就能够运行工作空间中编译好的ROS程序，我们习惯把source ~/tutorial_ws/devel/setup.bash命令追加到~/.bashrc文件中(tutorial_ws替换为你自己的工作空间名称)。这样每次打开终端，系统就会自动刷新工作空间环境了。你可以通过echo \"source ~/tutorial_ws/devel/setup.bash\" >> ~/.bashrc 命令来添加。 编译成功之后，就可以运行本教学配套的仿真程序了 输入命令：roslaunch robot_sim_demo robot_spawn.launch 你会看到仿真画面启动，仿真界面中包括了软件博物馆和Xbot机器人模型。注：第一次启动gazebo仿真软件，会比较慢，需要耐心等待一下。 另外打开一个终端，输入命令：rosrun robot_sim_demo robot_keyboard_teleop.py 将会打开键盘控制程序，可以控制机器人移动。 聚焦键盘控制终端窗口，按下I，J,L等按键，这样就通过键盘控制机器人移动了。 当完成了上面7个步骤之后，不知不觉中，我们就已经完成了ROS中最常见的源码下载->安装依赖->编译->运行的流程了。在ROS社区有许许多多这样的软件代码包，基本都按照这样的流程来运行。相信你一定可以举一反三。 "},"Chapter2/二进制vs源码安装.html":{"url":"Chapter2/二进制vs源码安装.html","title":"第二篇 二进制vs源码安装","keywords":"","body":"二进制安装 vs 源代码安装 1. 二进制包与源代码包 我们通过apt方式安装了ROS系统以及相关的软件包，我们也通过下载源码的方式编译安装了一个ROS教学代码包。这是两种常见的软件包安装方式，通常我们的软件包(Package)就可以分为二进制和源代码。 二进制包里面包括了已经编译完成，可以直接运行的程序。通过 sudo apt-get install 来进行下载和解包（安装），执行完该指令后就可以马上使用了。因此这种方式简单快捷，适合比较固定、无需改动的程序。 而源代码包里是程序的原始代码，下载到你的计算机上必须经过编译，生成可执行的二进制文件之后，方可运行。一些个人开发的程序、第三方修改或者你希望修改的程序都应当通过源代码包的来编译安装。 区别 二进制包 源代码包 下载方式 apt-get install/直接下载deb git clone/直接下载源代码 ROS包存放位置 /opt/ros/kinetic/ 通常~/tutorial_ws/src 编译方式 无需编译 通过make/cmake/caktin_make 来源 官方apt软件源 开源项目、第三方开发者 扩展性 无法修改 通过源代码修改 可读性 无法查看源代码 方便阅读源代码 优点 下载简单，安装方便 源码可修改，便于定制功能 缺点 无法修改 编译工具、软件包依赖、版本和参数 应用场景 基础软件 需要查看、开发和修改的程序 我们用apt-get安装了ROS及其组件，因此我们不需要编译就可以运行turtlesim程序。对于这些程序，除非我们做操作系统的设计开发才会去下载源码，否则直接用官方提供的ROS软件包；而ROS-Academy-for-Beginners以源码呈现，你可以看到每个demo下面的C++源代码。对于这些源文件我们必须caktin_make编译，然后才能运行。 2. ROS二进制包的安装 在ROS中，我们可能经常会遇到缺少相关的ROS依赖的问题。有些时候你编译或者运行一些ROS程序，系统会提示找不到XXX功能包，如图所示。遇到这样的问题，请先注意阅读错误原因，看看是否有解决方法，也可以Google一下。如果是缺少ROS的依赖，通常可以用以下命令来安装： sudo apt-get install ros-kinetic-PACAKGE 将PACKAGE替换为系统提示缺少的软件包，例如 sudo apt-get install ros-kinetic-slam-gmapping #GMapping-SLAM算法包 sudo apt-get install ros-kinetic-turtlebot-description #Turtlebot机器人模型包 注：所有APT官方中的ROS功能包都是按照 ros- 的形式来命名的。 "},"Chapter2/安装RoboWareStudio.html":{"url":"Chapter2/安装RoboWareStudio.html","title":"第三篇 安装RoboWare Studio","keywords":"","body":"安装 RoboWare Studio 通常ROS的程序都是用C++和Python开发的，为了提高开发的效率，我们建议用IDE来写代码。目前在Ubuntu上已经有许多IDE支持ROS开发，比如Eclipse、Qt Creator。不过这些IDE配置起来会比较麻烦，我们推荐一款适配ROS的IDE——RoboWare Studio来开发ROS。 RoboWare Studio现在官网已经不存在了，在2018年就不再维护更新了。这个软件是开源的，我们还是可以继续使用的。 我保存了RoboWare Studio的最后一个更新版本和中英文软件使用手册。可以访问我的github仓库地址，进行下载使用。 micro-coder/RoboWare_Studio_1.2.0 "},"Chapter2/catkin编译系统.html":{"url":"Chapter2/catkin编译系统.html","title":"第四篇 catkin编译系统","keywords":"","body":"catkin编译系统 介绍了ROS的工程结构，也就是ROS的文件系统结构。要学会建立一个ROS工程，首先要认识一个ROS工程，了解它的组织架构，从根本上熟悉ROS项目的组织形式，了解各个文件的功能和作用，才能正确的进行开发和编程。 1. 概念 对于源代码包，我们只有编译完成之后，才能在系统上运行。而Linux下的编译器有gcc、g++，随着源文件的增加，直接用gcc/g++命令的方式显得效率低下，人们开始用Makefile来进行编译。然而随着工程体量的增大，Makefile也不能满足需求，于是便出现了Cmake工具。CMake是对make工具的生成器，是更高层的工具，它简化了编译构建过程，能够管理大型项目，具有良好的可扩展性。对于ROS这样大体量的平台来说，采用的就是CMake，并且ROS对CMake进行了扩展，于是便有了Catkin编译系统。 **早期的ROS编译系统是rosbuild**，但随着ROS的不断发展，rosbuild逐渐暴露出许多缺点，不能很好满足系统需要。**在Groovy版本面世后，Catkin作为rosbuild的替代品被正式投入使用。**Catkin操作更加简化且工作效率更高，可移植性更好，而且支持交叉编译和更加合理的功能包分配。目前的ROS同时支持着rosbuild和Catkin两种编译系统，但ROS的核心软件包也已经全部转换为Catkin。**rosbuild已经被逐步淘汰，所以建议初学者直接上手Catkin。** 2. catkin特点 Catkin是基于CMake的编译构建系统，具有以下特点： Catkin沿用了包管理的传统像 find_package()基础结构,pkg-config 扩展了CMake，例如 软件包编译后无需安装就可使用 自动生成find_package()代码，pkg-config文件 解决了多个软件包构建顺序问题 一个Catkin的软件包（package）必须要包括两个文件： package.xml : 包括了package的描述信息 name, description, version, maintainer(s), license opt. authors, url's, dependencies, plugins, etc... CMakeLists.txt: 构建package所需的CMake文件 调用Catkin的函数/宏 解析package.xml 找到其他依赖的catkin软件包 将本软件包添加到环境变量 3. catkin工作原理 catkin编译的工作流程如下： 首先在工作空间catkin_ws/src/下递归的查找其中每一个ROS的package。 package中会有package.xml和CMakeLists.txt文件，Catkin(CMake)编译系统依据CMakeLists.txt文件,从而生成makefiles(放在catkin_ws/build/)。 然后make刚刚生成的makefiles等文件，编译链接生成可执行文件(放在catkin_ws/devel)。 也就是说，Catkin就是将cmake与make指令做了一个封装从而完成整个编译过程的工具。catkin有比较突出的优点，主要是： 操作更加简单 一次配置，多次使用 跨依赖项目编译 4. catkin编译方法 要用catkin编译一个工程或软件包，只需要用catkin_make指令。一般当我们写完代码，执行一次catkin_make进行编译,就会自动完成编译和链接过程，构建生成目标文件。编译的一般性流程如下。在第一篇 学习资料源码下载我们编译ROS-Academy-for-Beginners教学包就是这样的步骤。cd ~/catkin_ws #进入到工作空间,catkin_make必须在工作空间的顶层目录下执行 catkin_make #开始编译 source ~/catkin_ws/devel/setup.bash #刷新坏境 注：这里的catkin_ws替换为tutorial_ws。前面已经说明过了，tutorial_ws或者catkin_ws只是文件夹名称，名称可以随意注: 使用catkin编译之前，必须回到工作空间的顶层目录，catkin_make在其他路径下编译不会成功。编译完成后，如果有新的目标文件产生，那么一般紧跟着要用source刷新一下环境，使得系统能够找到刚才编译生成的ROS可执行文件。这个细节比较容易遗漏，致使后面出现可执行文件无法打开等错误 catkin_make命令也有一些可选参数，例如：catkin_make [args]-h, --help 帮助信息 -C DIRECTORY, --directory DIRECTORY 工作空间的路径 (默认为 '.') --source SOURCE src的路径 (默认为'workspace_base/src') --build BUILD build的路径 (默认为'workspace_base/build') --use-ninja 用ninja取代make --use-nmake 用nmake取'make --force-cmake 强制cmake，即使已经cmake过 --no-color 禁止彩色输出(只对catkin_make和CMake生效) --pkg PKG [PKG ...] 只对某个PKG进行make --only-pkg-with-deps ONLY_PKG_WITH_DEPS [ONLY_PKG_WITH_DEPS ...] 将指定的package列入白名单 CATKIN_WHITELIST_PACKAGES， 之编译白名单里的package。该环境变量存在于 CMakeCache.txt。 --cmake-args [CMAKE_ARGS [CMAKE_ARGS ...]] 传给CMake的参数 --make-args [MAKE_ARGS [MAKE_ARGS ...]] 传给Make的参数 --override-build-tool-check 用来覆盖由于不同编译工具产生的错误 "},"Chapter2/catkin工作空间.html":{"url":"Chapter2/catkin工作空间.html","title":"第五篇 catkin工作空间","keywords":"","body":"Catkin工作空间 Catkin工作空间是创建、修改、编译catkin软件包的文件夹。catkin的工作空间，直观的形容就是一个仓库，里面装载着ROS的各种项目工程，便于系统组织管理调用。在可视化图形界面里是一个文件夹。我们自己写的ROS代码通常就放在工作空间中。本篇就来介绍catkin工作空间的结构。 一、创建初始工作空间 介绍完catkin编译系统，我们来建立一个catkin的初始工作空间。首先我们要在计算机上创建一个初始的catkin_ws/src，这也是catkin工作空间结构的最高层级。输入下列指令，完成初始创建。 mkdir -p ~/catkin_ws/src　　 cd ~/catkin_ws/ catkin_make #初始化工作空间 第一行代码直接创建了文件夹catkin_ws文件夹和src子文件夹，这也是我们放ROS软件包的地方。第二行代码进入工作空间catkin_ws，然后再是catkin_make。 注： catkin_make命令必须在工作空间这个路径上执行 原先的初始化命令catkin_init_workspace仍然保留 二、工作空间结构 catkin的结构十分清晰，具体的catkin工作空间结构图如下。初看起来catkin工作空间看起来极其复杂，其实不然，catkin工作空间的结构其实非常清晰。 为了更形象的显示目录文件结构，这里我们需要先下载安装一个tree工具： sudo apt install tree 然后在工作空间下用tree命令，显示文件结构。 cd ~/catkin_ws tree 结果类似于： ─ build │ ├── catkin │ │ └── catkin_generated │ │ └── version │ │ └── package.cmake │ ├── ...... │ ├── catkin_make.cache │ ├── CMakeCache.txt │ ├── CMakeFiles │ │ ├── ...... ├── devel │ ├── env.sh │ ├── lib │ ├── setup.bash │ ├── setup.sh │ ├── _setup_util.py │ └── setup.zsh └── src └── CMakeLists.txt -> /opt/ros/kinetic/share/catkin/cmake/toplevel.cmake 通过tree命令可以看到catkin工作空间的结构,它包括了src、build、devel三个文件路径，在有些编译选项下也可能包括其他。但这三个文件夹是catkin编译系统默认的。它们的具体作用如下： src/: ROS的catkin软件包(源代码包)；自己手动创建; build/: catkin(CMake)的缓存信息和中间文件；自动生成; devel/: 用于存放生成的目标文件(包括头文件，动态链接库，静态链接库，可执行文件等)、环境变量(setup.bash等)；自动生成; 在编译过程中，它们的工作流程如图： 后两个路径由catkin系统自动生成、管理，我们日常的开发一般不会去涉及。而主要用到的是src文件夹，我们写的ROS程序、网上下载的ROS源代码包都存放在这里。在编译时，catkin编译系统会递归的查找和编译src/下的每一个源代码包。因此你也可以把几个源代码包放到同一个文件夹下，如下图所示： 小结 catkin工作空间基本就是以上的结构，package是catkin工作空间的基本单元，我们在ROS开发时，写好代码，然后catkin_make，系统就会完成所有编译构建的工作。至于更详细的package内容，我们将在下一篇继续介绍。 "},"Chapter2/package.html":{"url":"Chapter2/package.html","title":"第六篇 package包","keywords":"","body":"package包 在前面第二篇分别介绍了二进制包和源代码包。ROS中对package的定义更加具体，它不仅是Linux上的软件包，更是catkin编译的基本单元，我们调用catkin_make编译的对象就是一个个ROS的package，也就是说任何ROS程序只有组织成package才能编译。所以package也是ROS源代码存放的地方，任何ROS的代码无论是C++还是Python都要放到package中，这样才能正常的编译和运行。一个package可以编译出来多个目标文件（ROS可执行程序、动态静态库、头文件等等）。 一、package结构 一个package下常见的文件、路径有： ├── CMakeLists.txt #package的编译规则(必须) ├── package.xml #package的描述信息(必须) ├── src/ #源代码文件 ├── include/ #C++头文件 ├── scripts/ #可执行脚本 ├── msg/ #自定义消息 ├── srv/ #自定义服务 ├── models/ #3D模型文件 ├── urdf/ #urdf文件 ├── launch/ #launch文件 其中定义package的是CMakeLists.txt和package.xml，这两个文件是package中必不可少的。catkin编译系统在编译前，首先就要解析这两个文件。这两个文件就定义了一个package。 CMakeLists.txt: 定义package的包名、依赖、源文件、目标文件等编译规则，是package不可少的成分 package.xml: 描述package的包名、版本号、作者、依赖等信息，是package不可少的成分 src/: 存放ROS的源代码，包括C++的源码和(.cpp)以及Python的module(.py) include/: 存放C++源码对应的头文件 scripts/: 存放可执行脚本，例如shell脚本(.sh)、Python脚本(.py) msg/: 存放自定义格式的消息(.msg) srv/: 存放自定义格式的服务(.srv) models/: 存放机器人或仿真场景的3D模型(.sda, .stl, .dae等) urdf/: 存放机器人的模型描述(.urdf或.xacro) launch/: 存放launch文件(.launch或 .xml) 通常ROS文件组织都是按照以上的形式，这是约定俗成的命名习惯，建议遵守。以上路径中，只有CMakeLists.txt和package.xml是必须的，其余路径根据软件包是否需要来决定。 二、package的创建 创建一个package需要在catkin_ws/src下,用到 catkin_create_pkg命令，用法是： catkin_create_pkg package depends 其中package是包名，depends是依赖的包名，可以依赖多个软件包。例如，新建一个package叫做test_pkg,依赖roscpp、rospy、std_msgs(这些都是常用依赖)。 catkin_create_pkg test_pkg roscpp rospy std_msgs 这样就会在当前路径下新建test_pkg软件包，包括： ├── CMakeLists.txt ├── include │ └── test_pkg ├── package.xml └── src 如图所示： catkin_create_pkg帮你完成了软件包的初始化，填充好了CMakeLists.txt和package.xml，并且将依赖项填进了这两个文件中。 三、package相关命令 1. rospack rospack是对package管理的工具，命令的用法如下： rostopic命令 作用 rospack help 显示rospack的用法 rospack list 列出本机所有package rospack depends [package] 显示package的依赖包 rospack find [package] 定位某个package rospack profile 刷新所有package的位置记录 注：以上命令如果package缺省，则默认为当前目录(如果当前目录包含package.xml) 2. roscd roscd 命令类似与Linux系统的 cd ，改进之处在于roscd可以直接cd到ROS的软件包。 rostopic命令 作用 roscd [pacakge] cd到ROS package所在路径 3. rosls rosls也可以视为Linux指令ls的改进版，可以直接lsROS软件包的内容。 rosls命令 作用 rosls [pacakge] 列出pacakge下的文件 4. rosdep rosdep是用于管理ROS package依赖项的命令行工具，用法如下： rosdep命令 作用 rosdep check [pacakge] 检查package的依赖是否满足 rosdep install [pacakge] 安装pacakge的依赖 rosdep db 生成和显示依赖数据库 rosdep init 初始化/etc/ros/rosdep中的源 rosdep keys 检查package的依赖是否满足 rosdep update 更新本地的rosdep数据库 一个较常使用的命令是rosdep install --from-paths src --ignore-src --rosdistro=kinetic -y,用于安装工作空间中src路径下所有package的依赖项（由pacakge.xml文件指定）。这个指令在第一篇 学习资料源码下载使用过。 "},"Chapter2/CMakeLists.txt.html":{"url":"Chapter2/CMakeLists.txt.html","title":"第七篇 CMakeLists.txt","keywords":"","body":"CMakeLists.txt CMakeLists.txt原本是Cmake编译系统的规则文件，而Catkin编译系统基本沿用了CMake的编译风格，只是针对ROS工程添加了一些宏定义。所以在写法上，catkin的CMakeLists.txt与CMake的基本一致。 这个文件直接规定了这个package要依赖哪些package，要编译生成哪些目标，如何编译等等流程。所以CMakeLists.txt非常重要，它指定了由源码到目标文件的规则，catkin编译系统在工作时首先会找到每个package下的CMakeLists.txt，然后按照规则来编译构建。 一、CMakeLists.txt写法 CMakeLists.txt的基本语法都还是按照CMake，而Catkin在其中加入了少量的宏，总体的结构如下： cmake_minimum_required() #CMake的版本号 project() #项目名称 find_package() #找到编译需要的其他CMake/Catkin package catkin_python_setup() #catkin新加宏，打开catkin的Python Module的支持 add_message_files() #catkin新加宏，添加自定义Message/Service/Action文件 add_service_files() add_action_files() generate_message() #catkin新加宏，生成不同语言版本的msg/srv/action接口 catkin_package() #catkin新加宏，生成当前package的cmake配置，供依赖本包的其他软件包调用 add_library() #生成库 add_executable() #生成可执行二进制文件 add_dependencies() #定义目标文件依赖于其他目标文件，确保其他目标已被构建 target_link_libraries() #链接 catkin_add_gtest() #catkin新加宏，生成测试 install() #安装至本机 如果你从未接触过CMake的语法，请阅读《CMake实践》 。掌握CMake语法对于理解ROS工程很有帮助。 CMakeLists例子 为了详细的解释CMakeLists.txt的写法，我们以turtlesim小海龟这个pacakge为例，读者可roscd到tuetlesim包下查看，在turtlesim/CMakeLists.txt的写法如下: cmake_minimum_required(VERSION 2.8.3) #CMake至少为2.8.3版 project(turtlesim) #项目(package)名称为turtlesim，在后续文件中可使用变量${PROJECT_NAME}来引用项目名称turltesim find_package(catkin REQUIRED COMPONENTS geometry_msgs message_generation rosconsole roscpp roscpp_serialization roslib rostime std_msgs std_srvs) #cmake宏，指定依赖的其他pacakge，实际是生成了一些环境变量，如_FOUND, _INCLUDE_DIRS, _LIBRARYIS #此处catkin是必备依赖 其余的geometry_msgs...为组件 find_package(Qt5Widgets REQUIRED) find_package(Boost REQUIRED COMPONENTS thread) include_directories(include ${catkin_INCLUDE_DIRS} ${Boost_INCLUDE_DIRS}) #指定C++的头文件路径 link_directories(${catkin_LIBRARY_DIRS}) #指定链接库的路径 add_message_files(DIRECTORY msg FILES Color.msg Pose.msg) #自定义msg文件 add_service_files(DIRECTORY srv FILES Kill.srv SetPen.srv Spawn.srv TeleportAbsolute.srv TeleportRelative.srv) #自定义srv文件 generate_messages(DEPENDENCIES geometry_msgs std_msgs std_srvs) #在add_message_files、add_service_files宏之后必须加上这句话，用于生成srv msg头文件/module，生成的文件位于devel/include中 catkin_package(CATKIN_DEPENDS geometry_msgs message_runtime std_msgs std_srvs) # catkin宏命令，用于配置ROS的package配置文件和CMake文件 # 这个命令必须在add_library()或者add_executable()之前调用，该函数有5个可选参数： # (1) INCLUDE_DIRS - 导出包的include路径 # (2) LIBRARIES - 导出项目中的库 # (3) CATKIN_DEPENDS - 该项目依赖的其他catkin项目 # (4) DEPENDS - 该项目所依赖的非catkin CMake项目。 # (5) CFG_EXTRAS - 其他配置选项 set(turtlesim_node_SRCS src/turtlesim.cpp src/turtle.cpp src/turtle_frame.cpp ) set(turtlesim_node_HDRS include/turtlesim/turtle_frame.h ) #指定turtlesim_node_SRCS、turtlesim_node_HDRS变量 qt5_wrap_cpp(turtlesim_node_MOCS ${turtlesim_node_HDRS}) add_executable(turtlesim_node ${turtlesim_node_SRCS} ${turtlesim_node_MOCS}) # 指定可执行文件目标turtlesim_node target_link_libraries(turtlesim_node Qt5::Widgets ${catkin_LIBRARIES} ${Boost_LIBRARIES}) # 指定链接可执行文件 add_dependencies(turtlesim_node turtlesim_gencpp) add_executable(turtle_teleop_key tutorials/teleop_turtle_key.cpp) target_link_libraries(turtle_teleop_key ${catkin_LIBRARIES}) add_dependencies(turtle_teleop_key turtlesim_gencpp) add_executable(draw_square tutorials/draw_square.cpp) target_link_libraries(draw_square ${catkin_LIBRARIES} ${Boost_LIBRARIES}) add_dependencies(draw_square turtlesim_gencpp) add_executable(mimic tutorials/mimic.cpp) target_link_libraries(mimic ${catkin_LIBRARIES}) add_dependencies(mimic turtlesim_gencpp) # 同样指定可执行目标、链接、依赖 install(TARGETS turtlesim_node turtle_teleop_key draw_square mimic RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}) # 安装目标文件到本地系统 install(DIRECTORY images DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION} FILES_MATCHING PATTERN \"*.png\" PATTERN \"*.svg\") "},"Chapter2/package_xml.html":{"url":"Chapter2/package_xml.html","title":"第八篇 package.xml","keywords":"","body":"package.xml package.xml也是一个catkin的package必备文件，它是这个软件包的描述文件，在较早的ROS版本(rosbuild编译系统)中，这个文件叫做manifest.xml，用于描述pacakge的基本信息。如果你在网上看到一些ROS项目里包含着manifest.xml，那么它多半是hydro版本之前的项目。 package.xml作用 pacakge.xml包含package的名称、版本号、内容描述、维护人员、软件许可、编译构建工具、编译依赖、运行依赖等信息。 实际上rospack find、rosdep等命令之所以能快速定位和分析出package的依赖项信息，就是直接读取了每一个pacakge中的package.xml文件。它为用户提供了快速了解一个pacakge的渠道。 package.xml写法 pacakge.xml遵循xml标签文本的写法，由于版本更迭原因，现在有两种格式并存（format1与format2），不过区别不大。老版本（format1）的pacakge.xml通常包含以下标签: 根标记文件 包名 版本号 内容描述 维护者 软件许可证 编译构建工具，通常为catkin 编译依赖项，与Catkin中的 运行依赖项 说明：其中1-6为必备标签，1是根标签，嵌套了其余的所有标签，2-6为包的各种属性，7-9为编译相关信息。 在新版本（format2）中，包含的标签为： 根标记文件 包名 版本号 内容描述 维护者 软件许可证 编译构建工具，通常为catkin 指定依赖项为编译、导出、运行需要的依赖，最常用 编译依赖项 导出依赖项 运行依赖项 测试用例依赖项 文档依赖项 目前Indigo、Kinetic、Lunar等版本的ROS都同时支持两种版本的package.xml，所以无论选哪种格式都可以。 package.xml例子 为了说明pacakge.xml写法，还是以turtlesim软件包为例，其pacakge.xml文件内容如下，我们添加了相关的注释： turtlesim 0.8.1 turtlesim is a tool made for teaching ROS and ROS packages. Dirk Thomas BSD http://www.ros.org/wiki/turtlesim https://github.com/ros/ros_tutorials/issues https://github.com/ros/ros_tutorials Josh Faust catkin geometry_msgs qtbase5-dev message_generation qt5-qmake rosconsole roscpp roscpp_serialization roslib rostime std_msgs std_srvs geometry_msgs libqt5-core libqt5-gui message_runtime rosconsole roscpp roscpp_serialization roslib rostime std_msgs std_srvs 以上内容是老版本（format1）的写法，如果要写成新版本（format2）则可以改为： turtlesim 0.8.1 turtlesim is a tool made for teaching ROS and ROS packages. Dirk Thomas BSD http://www.ros.org/wiki/turtlesim https://github.com/ros/ros_tutorials/issues https://github.com/ros/ros_tutorials Josh Faust catkin geometry_msgs rosconsole roscpp roscpp_serialization roslib rostime std_msgs std_srvs qtbase5-dev message_generation qt5-qmake libqt5-core libqt5-gui message_runtime "},"Chapter2/Metapackage.html":{"url":"Chapter2/Metapackage.html","title":"第九篇 Metapackage","keywords":"","body":"Metapackage 在一些ROS的教学资料和博客里，你可能还会看到一个Stack（功能包集）的概念，它指的是将多个功能接近、甚至相互依赖的软件包的放到一个集合中去。但Stack这个概念在Hydro之后就取消了，取而代之的就是Metapackage。尽管换了个马甲，但它的作用没变，都是把一些相近的功能模块、软件包放到一起。 ROS里常见的Metapacakge有： Metapacakge名称 描述 链接 navigation 导航相关的功能包集 https://github.com/ros-planning/navigation moveit 运动规划相关的（主要是机械臂）功能包集 https://github.com/ros-planning/moveit image_pipeline 图像获取、处理相关的功能包集 https://github.com/ros-perception/image_common vision_opencv ROS与OpenCV交互的功能包集 https://github.com/ros-perception/vision_opencv turtlebot Turtlebot机器人相关的功能包集 https://github.com/turtlebot/turtlebot pr2_robot pr2机器人驱动功能包集 https://github.com/PR2/pr2_robot ... ... ... 以上列举了一些常见的功能包集，例如navigation、turtlebot，他们都是用于某一方面的功能，以navigation metapackage（官方介绍里仍然沿用stack的叫法）为例，它包括了以下软件包： 包名 功能 navigation Metapacakge，依赖以下所有pacakge amcl 定位 fake_localization 定位 map_server 提供地图 move_base 路径规划节点 nav_core 路径规划的接口类 base_local_planner 局部规划 dwa_local_planner 局部规划 ... ... 这里只看一个软件包navigation。这个navigation就是一个简单的pacakge，里面只有几个文件，但由于它依赖了其他所有的软件包。Catkin编译系统会明白，这些软件包都属于navigation metapacakge。 这个道理并不难理解，比如我们在安装ROS时，用到了sudo apt-get install ros-kinetic-desktop-full命令，由于它依赖了ROS所有的核心组件，我们在安装时也就能够安装整个ROS。 Metapackage写法 我们以ROS-Academy-for-beginners为例介绍meteapckage的写法。在教学包内，有一个ros-academy-for-beginners软件包，该包即为一个metapacakge，其中有且仅有两个文件：CMakeLists.txt和pacakge.xml。(这两个文件在github下载页中) CMakeLists.txt写法如下： cmake_minimum_required(VERSION 2.8.3) project(ros_academy_for_beginners) find_package(catkin REQUIRED) catkin_metapackage() package.xml写法如下: ros_academy_for_beginners 18.2.10 -------------------------------------------------------------------------- A ROS tutorial for beginner level learners. This metapacakge includes some demos of topic, service, parameter server, tf, urdf, navigation, SLAM... It tries to explain the basic concepts and usages of ROS. -------------------------------------------------------------------------- Chai Changkun Chai Changkun BSD http://rosacademy.cn catkin navigation_sim_demo param_demo robot_sim_demo service_demo slam_sim_demo tf_demo topic_demo metapacakge中的以上两个文件和普通pacakge不同点是： CMakeLists.txt:加入了catkin_metapackage()宏，指定本软件包为一个metapacakge。 package.xml:标签将所有软件包列为依赖项，标签中添加标签声明。 metapacakge在我们实际开发一个大工程时可能有用 "},"Chapter2/其他常见文件类型.html":{"url":"Chapter2/其他常见文件类型.html","title":"第十篇 其他常见文件类型","keywords":"","body":"其他常见文件类型 在ROS的pacakge中，还有其他许多常见的文件类型，这里做个总结。 一、launch文件 launch文件一般以.launch或.xml结尾，它对ROS需要运行程序进行了打包，通过一句命令来启动。一般launch文件中会指定要启动哪些package下的哪些可执行程序，指定以什么参数启动，以及一些管理控制的命令。launch文件通常放在软件包的launch/路径中中。 二、msg/srv/action文件 ROS程序中有可能有一些自定义的消息/服务/动作文件，为程序的发者所设计的数据结构，这类的文件以.msg,.srv,.action结尾，通常放在package的msg/,srv/,action/路径下。 三、urdf/xacro文件 urdf/xacro文件是机器人模型的描述文件，以.urdf或.xacro结尾。它定义了机器人的连杆和关节的信息，以及它们之间的位置、角度等信息，通过urdf文件可以将机器人的物理连接信息表示出来。并在可视化调试和仿真中显示。 urdf文件的写法见第七章。 四、yaml文件 yaml文件一般存储了ROS需要加载的参数信息，一些属性的配置。通常在launch文件或程序中读取.yaml文件，把参数加载到参数服务器上。通常我们会把yaml文件存放在param/路径下 五、dae/stl文件 dae或stl文件是3D模型文件，机器人的urdf或仿真环境通常会引用这类文件，它们描述了机器人的三维模型。相比urdf文件简单定义的性状，dae/stl文件可以定义复杂的模型，可以直接从solidworks或其他建模软件导出机器人装配模型，从而显示出更加精确的外形。 六、rviz文件 rviz文件本质上是固定格式的文本文件，其中存储了RViz窗口的配置（显示哪些控件、视角、参数）。通常rviz文件不需要我们去手动修改，而是直接在RViz工具里保存，下次运行时直接读取。 "},"Chapter2/小结.html":{"url":"Chapter2/小结.html","title":"小结篇","keywords":"","body":"Chpaer 2 小结 "},"Chapter3/Introduction.html":{"url":"Chapter3/Introduction.html","title":"第三章 ROS通信架构体系","keywords":"","body":"Chapter 3 Introduction 本章学习ROS的通信架构，即ROS的各种通信方式。ROS的通信架构是ROS的灵魂，也是整个ROS正常运行的关键所在。ROS通信架构包括对各种数据的处理，进程的运行，消息的传递等等。本章介绍通信架构的基础通信方式和相关概念。首先介绍最小的进程单元节点 Node,和节点管理器Node master。了解ROS中的进程都是由很多的Node组成，并且由Node master来管理这些节点。 第二篇介绍ROS的“发动机”——launch文件，学习它的格式和内容，更深入的理解ROS在启动运行时它的工作都是由什么进程支配的，从而理解启动运行的原理。 在后面的几篇中介绍ROS通信方式。ROS中的通信方式有四种，主题、服务、参数服务器、动作库。每个通信方式都有自己的特点，自己不同的适用方面。 "},"Chapter3/node&master.html":{"url":"Chapter3/node&master.html","title":"第一篇 node&master","keywords":"","body":"node & master 一、 node 在ROS的世界里，最小的进程单元就是节点（node）。一个软件包里可以有多个可执行文件，可执行文件在运行之后就成了一个进程(process)，这个进程在ROS中就叫做节点。 从程序角度来说，node就是一个可执行文件（通常为C++编译生成的可执行文件、Python脚本）被执行，加载到了内存之中；从功能角度来说，通常一个node负责者机器人的某一个单独的功能。由于机器人的功能模块非常复杂，我们往往不会把所有功能都集中到一个node上，而会采用分布式的方式，把鸡蛋放到不同的篮子里。例如有一个node来控制底盘轮子的运动，有一个node驱动摄像头获取图像，有一个node驱动激光雷达，有一个node根据传感器信息进行路径规划……这样做可以降低程序发生崩溃的可能性，试想一下如果把所有功能都写到一个程序中，模块间的通信、异常处理将会很麻烦。 我们在第二篇 ROS配置打开了小海龟的运动程序和键盘控制程序，在1.5节同样启动了键盘运动程序，这每一个程序便是一个node。ROS系统中不同功能模块之间的通信，也就是节点间的通信。我们可以把键盘控制替换为其他控制方式，而小海龟运动程序、机器人仿真程序则不用变化。这样就是一种模块化分工的思想。 二、master 由于机器人的元器件很多，功能庞大，因此实际运行时往往会运行众多的node，负责感知世界、控制运动、决策和计算等功能。那么如何合理的进行调配、管理这些node呢？这就要利用ROS提供给我们的节点管理器master, master在整个网络通信架构里相当于管理中心，管理着各个node。node首先在master处进行注册，之后master会将该node纳入整个ROS程序中。node之间的通信也是先由master进行“牵线”，才能两两的进行点对点通信。当ROS程序启动时，第一步首先启动master，由节点管理器处理依次启动node。 三、启动master和node 当我们要启动ROS时，首先输入命令: roscore 此时ROS master启动，同时启动的还有rosout和parameter server。其中rosout是负责日志输出的一个节点，其作用是告知用户当前系统的状态，包括输出系统的error、warning等等，并且将log记录于日志文件中。parameter server即是参数服务器，它并不是一个node，而是存储参数配置的一个服务器，后文我们会单独介绍。每一次我们运行ROS的节点前，都需要把master启动起来，这样才能够让节点node启动和注册。 masterq启动之后，节点管理器master就开始按照系统的安排协调进行启动具体的节点。节点就是一个进程，只不过在ROS中它被赋予了专用的名字里——node。在第二章我们介绍了ROS的文件系统，我们知道一个package中存放着可执行文件，可执行文件是静态的，当系统执行这些可执行文件，将这些文件加载到内存中，它就成为了动态的node。具体启动node的语句是： rosrun pkg_name node_name 通常我们运行ROS，就是按照这样的顺序启动。有时候节点太多，我们会选择用launch文件来启动。Master、Node之间以及Node之间的关系如下图所示： rosrun和rosnode命令 rosrun命令的详细用法如下： rosrun [--prefix cmd] [--debug] pkg_name node_name [ARGS] rosrun将会寻找package下的名为executable的可执行程序，将可选参数ARGS传入。 例如在gdb下运行ros程序： rosrun --prefix 'gdb -ex run --args' pkg_name node_name rosnode命令的详细作用列表如下： rosnode命令 作用 rosnode help rosnode使用帮助信息 rosnode list 列出当前运行的node信息 rosnode info node_name 显示出node的详细信息 rosnode kill node_name 结束某个node rosnode ping 测试连接节点 rosnode machine 列出在特定机器或列表机器上运行的节点 rosnode cleanup 清除不可到达节点的注册信息 以上命令中常用的为前三个，在开发调试时经常会需要查看当前node以及node信息，所以请记住这些常用命令。如果你想不起来，也可以通过rosnode help来查看rosnode命令的用法。 "},"Chapter3/launch.html":{"url":"Chapter3/launch.html","title":"第二篇 launch文件","keywords":"","body":"launch文件 机器人是一个系统工程，通常一个机器人运行操作时要开启很多个node，对于一个复杂的机器人的启动操作应该怎么做呢？当然，我们并不需要每个节点依次进行rosrun，ROS为我们提供了一个命令： 能一次性启动master和多个node。该命令是： roslaunch pkg_name file_name.launch roslaunch命令首先会自动检测系统的roscore有没有运行，也即是确认节点管理器master是否处于运行状态，如果master没有启动，那么roslaunch就会首先启动master，然后再按照launch文件的规则执行。launch文件里已经配置好了启动规则。 所以roslaunch就像是一个启动工具，能够一次性把多个节点按照我们预先的配置启动起来，减少我们在终端中一条条输入指令的麻烦。 一、lanunch文件写法与与格式 launch文件同样也遵循着xml格式规范，是一种标签文本，它的格式包括以下标签： 参考链接:http://wiki.ros.org/roslaunch/XML 二、launch示例 launch文件的写法和格式看起来内容比较复杂，我们先来介绍一个最简单的例子如下： 这是官网给出的一个最小的例子。文本中的信息是，它启动了一个单独的节点talker,该节点是包rospy_tutorials软件包中的节点。 然而实际中的launch文件要复杂很多，我们以Ros-Academy-for-Beginners中的robot_sim_demo为例： 这个launch文件相比上一个简单的例子来说，内容稍微有些复杂，它的作用是：启动gazebo模拟器，导入参数内容，加入机器人模型。 "},"Chapter3/topic.html":{"url":"Chapter3/topic.html","title":"第三篇 topic话题","keywords":"","body":"topic通信方式 ROS的通信方式是ROS最为核心的概念，ROS系统的精髓就在于它提供的通信架构。ROS的通信方式有以下四种： Topic 主题 Service 服务 Parameter Service 参数服务器 Actionlib 动作库 一、topic简介 ROS中的通信方式中，topic是常用的一种。对于实时性、周期性的消息，使用topic来传输是最佳的选择。topic是一种点对点的单向通信方式，这里的“点”指的是node，也就是说node之间可以通过topic方式来传递信息。 Topic是ROS里一种单向的异步通信的模型。一般是节点间分工明确，有的节点只负责发送，有的节点只负责接收处理。对于绝大多数的机器人应用场景，比如传感器数据收发，速度控制指令的收发，Topic模型是最适合的通信方式。 topic要经历下面几步的初始化过程：首先，publisher节点和subscriber节点都要到节点管理器进行注册，然后publisher会发布topic，subscriber在master的指挥下会订阅该topic，从而建立起sub-pub之间的通信。注意整个过程是单向的。其结构示意图如下： Subscriber接收消息会进行处理，一般这个过程叫做回调(Callback)。所谓回调就是指提前定义好了一个处理函数（写在代码中），当有消息来就会触发这个处理函数，此函数会对消息进行处理。 上图就是ROS的topic通信方式的流程示意图。topic通信属于一种异步的通信方式。下面我们通过一个示例来了解下如何使用topic通信。 二、topic通信示例 参考下图，我们以摄像头画面的发布、处理、显示为例,讲讲topic通信的流程。在机器人上的摄像头拍摄程序是一个node（圆圈表示,我们记作node1），当node1注册、运行、启动之后，它作为一个Publisher就开始发布topic。比如它发布了一个topic（方框表示），叫做/camera_rgb，是rgb颜色信息，即采集到的彩色图像。同时，node2假如是图像处理程序,它作为一个subscriber订阅了/camera_rgb这个topic，经过节点管理器的介绍，它就能建立和摄像头节点（node1）的连接。 那么怎么样来理解“异步”这个概念呢？在node1每发布一次消息之后，就会继续执行下一个动作，至于消息发出去之后是什么状态、被怎样处理，它不需要了解；而对于node2图像处理程序，它只管接收和处理/camera_rgb上的消息，至于是谁发来的，它不会关心。所以node1、node2两者都是各司其责，不存在协同工作，我们称这样的通信方式是异步的。 ROS是一种分布式的架构，同一个topic可以有多个节点同时发布，也可以同时被多个节点接收。比如在这个场景中，用户可以再加入一个图像显示的节点，我们还想看看摄像头节点的实时画面，则可以用自己的笔记本连接到机器人上的节点管理器，然后在自己的电脑上启动图像显示节点。 这就体现了分布式系统通信的好处：扩展性好、软件复用率高。 总结： topic通信方式是异步的，发送时调用publish()方法，发送完成立即返回，不用等待反馈。 subscriber通过回调函数的方式来处理消息。 topic可以同时有多个subscribers，也可以同时有多个publishers。ROS中这样的例子有：/rosout、/tf等等。 三、topic操作命令 在实际应用中，我们应该熟悉topic的几种使用命令，下表详细的列出了各自的命令及其作用。 命令 作用 rostopic list 列出当前所有的topic rostopic info topic_name 显示某个topic的属性信息 rostopic echo topic_name 显示某个topic的内容 rostopic pub topic_name ... 向某个topic发布内容 rostopic bw topic_name 查看某个topic的带宽 rostopic hz topic_name 查看某个topic的频率 rostopic find topic_type 查找某个类型的topic rostopic type topic_name 查看某个topic的类型(msg) 如果你一时忘记了命令的写法，可以通过rostopic help或rostopic command -h查看具体用法。 四、topic测试示例 首先打开ROS-Academy-for-Beginners的模拟场景，输入roslaunch robot_sim_demo robot_spawn_launch 看到我们仿真的模拟环境。该launch文件启动了模拟场景、机器人。 如图所示： 查看当前模拟器中存在的topic，输入命令rostopic list 可以看到终端输出许多topic，它们可以视为模拟器与外界交互的接口。 如图所示： 查询topic ： /camera/rgb/image_raw 的相关信息：rostopic info /camera/rgb/image_raw 则会显示类型信息type，发布者和订阅者的信息。 如图所示： 上步我们在演示中可以得知，并没有订阅者订阅该主题，我们指定image_view来接收这个消息，运行命令rosrun image_view image_view image:=/camera/rgb/image_raw 我们可以看到message，即是上一步中的type，并弹出一个图像窗口 如图所示： 同理我们可以查询摄像头的深度信息depth图像。 在用键盘控制仿真机器人运动的时候，我们可以查看速度指令topic的内容rostopic echo /cmd_vel ，可以看到窗口显示的各种坐标参数在不断的变化。 通过这些实例的测试，帮助我们更快的掌握topic各种操作命令的使用，以及对topic通信的理解。 "},"Chapter3/message.html":{"url":"Chapter3/message.html","title":"第四篇 msg消息格式","keywords":"","body":"msg消息格式 topic有很严格的格式要求，比如上节的摄像头进程中的rgb图像topic，它就必然要遵循ROS中定义好的rgb图像格式。这种数据格式就是Message。Message按照定义解释就是topic内容的数据类型，也称之为topic的格式标准。这里和我们平常用到的Massage直观概念有所不同，这里的Message不单单指一条发布或者订阅的消息，也指定为topic的格式标准。 msg文件就是一个描述ROS中所使用消息类型的简单文本。它们会被用来生成不同语言的源代码。 msg文件存放在package的msg目录下，srv文件则存放在srv目录下。 一、message结构与类型 msg文件实际上就是每行声明一个数据类型和变量名。可以使用的数据类型如下： int8, int16, int32, int64 (plus uint*)，以及uint(8,16,32,64)类型 float32, float64 string time, duration Header variable-length array[] and fixed-length array[C] 嵌套other msg files 在ROS中有一个特殊的数据类型：Header，它含有时间戳和坐标系信息。在msg文件的第一行经常可以看到Header header的声明. 基本的msg包括bool、int8、int16、int32、int64、float、float64、string、time、duration、header、可变长数组array[] 、固定长度数组array[C]。那么具体的一个msg是怎么组成的呢？我们用一个具体的msg来了解，例如上例中的msg：sensor_msg/image,文件的绝对路径是 /opt/ros/kinetic/share/sensor_msgs,它的结构如下： # This message contains an uncompressed image # (0, 0) is at top-left corner of image # Header header # Header timestamp should be acquisition time of image # Header frame_id should be optical frame of camera # origin of frame should be optical center of camera # +x should point to the right in the image # +y should point down in the image # +z should point into to plane of the image # If the frame_id here and the frame_id of the CameraInfo # message associated with the image conflict # the behavior is undefined uint32 height # image height, that is, number of rows uint32 width # image width, that is, number of columns # The legal values for encoding are in file src/image_encodings.cpp # If you want to standardize a new string format, join # ros-users@lists.sourceforge.net and send an email proposing a new encoding. string encoding # Encoding of pixels -- channel meaning, ordering, size # taken from the list of strings in include/sensor_msgs/image_encodings.h uint8 is_bigendian # is this data bigendian? uint32 step # Full row length in bytes uint8[] data # actual matrix data, size is (step * rows) 可以看到，这里还嵌套了Header结构体： # Standard metadata for higher-level stamped data types. # This is generally used to communicate timestamped data # in a particular coordinate frame. # # sequence ID: consecutively increasing ID uint32 seq #Two-integer timestamp that is expressed as: # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs') # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs') # time-handling sugar is provided by the client library time stamp #Frame this data is associated with # 0: no frame # 1: global frame string frame_id 观察上面msg的定义，是不是很类似C语言中的结构体呢？通过具体的定义图像的宽度，高度等等来规范图像的格式。所以这就解释了Message不仅仅是我们平时理解的一条一条的消息，而且更是ROS中topic的格式规范。或者可以理解msg是一个“类”，那么我们每次发布的内容可以理解为“对象”，这么对比来理解可能更加容易。 我们实际通常不会把Message概念分的那么清，通常说Message既指的是类，也是指它的对象。而msg文件则相当于类的定义了。 二、msg操作命令 rosmsg的命令相比topic就比较少了，只有两个如下： rosmsg命令 作用 rosmsg list 列出系统上所有的msg rosmsg show msg_name 显示某个msg的内容 三、常见msg消息格式 常见的message类型，包括std_msgs, sensor_msgs, nav_msgs, geometry_msgs等 Vector3.msg 文件位置:geometry_msgs/Vector3.msg float64 x float64 y float64 z Accel.msg 定义加速度项，包括线性加速度和角加速度文件位置:geometry_msgs/Accel.msg Vector3 linear Vector3 angular Header.msg 定义数据的参考时间和参考坐标文件位置:std_msgs/Header.msg uint32 seq #数据ID time stamp #数据时间戳 string frame_id #数据的参考坐标系 Echos.msg 定义超声传感器文件位置:自定义msg文件 Header header uint16 front_left uint16 front_center uint16 front_right uint16 rear_left uint16 rear_center uint16 rear_right Quaternion.msg 消息代表空间中旋转的四元数文件位置:geometry_msgs/Quaternion.msg float64 x float64 y float64 z float64 w Imu.msg 消息包含了从惯性原件中得到的数据，加速度为m/^2，角速度为rad/s如果所有的测量协方差已知，则需要全部填充进来如果只知道方差，则只填充协方差矩阵的对角数据即可文件位置：sensor_msgs/Imu.msg Header header Quaternion orientation float64[9] orientation_covariance Vector3 angular_velocity float64[9] angular_velocity_covariance Vector3 linear_acceleration float64[] linear_acceleration_covariance LaserScan.msg 平面内的激光测距扫描数据注意此消息类型仅仅适配激光测距设备,如果有其他类型的测距设备(如声呐)，需要另外创建不同类型的消息文件位置：sensor_msgs/LaserScan.msg Header header #时间戳为接收到第一束激光的时间 float32 angle_min #扫描开始时的角度(单位为rad) float32 angle_max #扫描结束时的角度(单位为rad) float32 angle_increment #两次测量之间的角度增量(单位为rad) float32 time_increment #两次测量之间的时间增量(单位为s) float32 scan_time #两次扫描之间的时间间隔(单位为s) float32 range_min #距离最小值(m) float32 range_max #距离最大值(m) float32[] ranges #测距数据(m,如果数据不在最小数据和最大数据之间，则抛弃) float32[] intensities #强度，具体单位由测量设备确定，如果仪器没有强度测量，则数组为空即可 Point.msg 空间中的点的位置文件位置:geometry_msgs/Point.msg float64 x float64 y float64 z Pose.msg 消息定义自由空间中的位姿信息，包括位置和指向信息文件位置:geometry_msgs/Pose.msg Point position Quaternion orientation PoseStamped.msg 定义有时空基准的位姿文件位置：geometry_msgs/PoseStamped.msg Header header Pose pose PoseWithCovariance.msg 表示空间中含有不确定性的位姿信息文件位置：geometry_msgs/PoseWithCovariance.msg Pose pose float64[36] covariance Power.msg 表示电源状态，是否开启文件位置：自定义msg文件 Header header bool power ###################### bool ON = 1 bool OFF = 0 Twist.msg 定义空间中物体运动的线速度和角速度文件位置：geometry_msgs/Twist.msg Vector3 linear Vector3 angular TwistWithCovariance.msg 消息定义了包含不确定性的速度量，协方差矩阵按行分别表示：沿x方向速度的不确定性，沿y方向速度的不确定性，沿z方向速度的不确定性绕x转动角速度的不确定性，绕y轴转动的角速度的不确定性，绕z轴转动的角速度的不确定性文件位置：geometry_msgs/TwistWithCovariance.msg Twist twist float64[36] covariance #分别表示[x; y; z; Rx; Ry; Rz] Odometry.msg 消息描述了自由空间中位置和速度的估计值文件位置：nav_msgs/Odometry.msg Header header string child_frame_id PoseWithCovariance pose TwistWithCovariance twist "},"Chapter3/service.html":{"url":"Chapter3/service.html","title":"第五篇 service服务","keywords":"","body":"service 服务 上一篇我们介绍了ROS的通信方式中的topic(主题)通信，我们知道topic是ROS中的一种单向的异步通信方式。然而有些时候单向的通信满足不了通信要求，比如当一些节点只是临时而非周期性的需要某些数据，如果用topic通信方式时就会消耗大量不必要的系统资源，造成系统的低效率高功耗。 这种情况下，就需要有另外一种请求-查询式的通信模型(C/S模型)。这节我们来介绍ROS通信中的另一种通信方式——service(服务)。 一、service工作原理 为了解决以上问题，service方式在通信模型上与topic做了区别。Service通信是双向的，它不仅可以发送消息，同时还会有反馈。所以service包括两部分，一部分是请求方（Client），另一部分是应答方/服务提供方（Server）。请求方（Client）发送一个request，要等待server处理，处理完成之后，server反馈回一个reply，这样通过类似“请求-应答”的机制完成整个服务通信。 这种通信方式的示意图如下： Node B是server（应答方），提供了一个服务的接口，叫做/Service，我们一般都会用string类型来指定service的名称，类似于topic。Node A向Node B发起请求，经过Node B处理后，Node A得到了反馈。 通信过程：Service是同步通信方式，所谓同步就是说： Node A发布请求后会在原地等待reply。 Node B处理完成之后，返回一个reply。 Node A继续执行。 Node A等待过程中，是处于阻塞状态的。这样的通信模型没有频繁的消息传递，没有冲突与高系统资源的占用，只有接受请求才执行服务，简单而且高效。 二、topic vs service 我们对比一下这两种最常用的通信方式，加深我们对两者的理解和认识，具体见下表： 名称 Topic Service 通信方式 异步通信 同步通信 实现原理 TCP/IP TCP/IP 通信模型 Publish-Subscribe Request-Reply 映射关系 Publish-Subscribe(多对多) Request-Reply（多对一） 特点 接受者收到数据会回调（Callback） 远程过程调用（RPC）服务器端的服务 应用场景 连续、高频的数据发布 低频(偶尔)使用的功能/具体的任务 举例 激光雷达、里程计发布数据 开关传感器、拍照、逆解计算 注意：远程过程调用(Remote Procedure Call，RPC),可以简单通俗的理解为在一个进程里调用另一个进程的函数。 　三、service操作命令 在实际应用中，service通信方式的命令时rosservice，具体的命令参数如下表： rosservice 命令 作用 rosservice list 显示服务列表 rosservice info 打印服务信息 rosservice type 打印服务类型 rosservice uri 打印服务ROSRPC uri rosservice find 按服务类型查找服务 rosservice call 使用所提供的args调用服务 rosservice args 打印服务参数 四、测试示例 首先依然是打开我们教材的模拟场景：roslaunch robot_sim_demo robot_spawn.launch。 输入rosservice list，查看当前运行的服务。 随机选择/gazebo/delete_light服务，观察名称，是删除光源的操作。 输入rosservice info /gazebo/delete_light查看属性信息。可以看到信息，Node：/gazebo，Type：gazebo_msgs/DeleteLight, Args：Light_name。这里的类型type也就是下文介绍的srv,传递参数Light_name 输入rosservice call /gazebo/delete_light sun,这里的sun 是参数名，使我们模拟场景中的唯一光源太阳。操作完成后可以看到场景中的光线消失。 前： 后： 可以看到终端的回传信息：success: True和sun successfully deleted。这就是双向通信的信息反馈，通知操作已经成功完成。 五、小结 Service是一种请求-反馈的通信机制。请求的一方通常被称为客户端，提供服务的一方叫做服务器端。Service机制相比于Topic的不同之处在于： 消息的传输是双向的，有反馈的，而不是单一的流向。 消息往往不会以固定频率传输，不连续，而是在需要时才会向服务器发起请求。 "},"Chapter3/srv.html":{"url":"Chapter3/srv.html","title":"第六篇 srv文件","keywords":"","body":"srv文件 一个srv文件描述一项服务。它包含两个部分：请求和响应 msg文件存放在package的msg目录下，srv文件则存放在srv目录下。 类似msg文件，srv文件是用来描述服务(service)数据类型的，service通信的数据格式就定义在*.srv格式的文件中。它声明了一个服务类型，包括请求(request)和响应（reply）两部分。其格式声明如下，举例： msgs_demo/srv/DetectHuman.srv bool start_detect #client请求服务格式 --- #分界线 my_pkg/HumanPose[] pose_data #server返回数据格式 msgs_demo/msg/HumanPose.msg std_msgs/Header header string uuid int32 number_of_joints my_pkg/JointPose[] joint_data msgs_demo/msg/JointPose.msg string joint_name geometry_msgs/Pose pose float32 confidence 以DetectHUman.srv文件为例，该服务例子取自OpenNI的人体检测ROS软件包。它是用来查询当前深度摄像头中的人体姿态和关节数的。srv文件格式很固定，第一行是请求的格式，中间用---隔开，第三行是应答的格式。在本例中，请求为是否开始检测，应答为一个数组，数组的每个元素为某个人的姿态（HumanPose）。而对于人的姿态，其实是一个msg。所以msg可以嵌套msg。srv也可以嵌套msg，但不能嵌套srv。 操作命令 具体的操作指令如下表： rossrv 命令 作用 rossrv show 显示服务描述 rossrv list 列出所有服务 rossrv md5 显示服务md5sum rossrv package 列出包中的服务 rossrv packages 列出包含服务的包 生成头文件 定义好了msg、srv文件之后，我们写的C++程序还不能直接使用.msg或者.srv文件内容。所以接下来，我们还需要做一些步骤，使.msg或者.srv文件变成.h头文件。 修改package.xml文件，添加依赖信息catkin message_generation roscpp rospy std_msgs roscpp rospy std_msgs message_runtime 修改CMakeLists.txt,声明.msg或者.srv文件信息，也添加依赖 find_package(catkin REQUIRED COMPONENTS message_generation roscpp rospy std_msgs ) add_message_files( FILES DetectHuman.srv HumanPose.msg JointPos.msg ) catkin_package( # INCLUDE_DIRS include # LIBRARIES publish_subscribe_demo CATKIN_DEPENDS roscpp rospy std_msgs message_runtime # DEPENDS system_lib ) 最后一步，执行编译命令，.msg或者.srv文件编译后生成文件就是相同文件名的.h头文件了catkin_make 谨记：执行`catkin_make`必须在工作空间的最顶层目录执行。 编译生成的头文件在 `devel/include/` 的文件里 常用srv类型 介绍常见的srv类型及其定义， srv类型相当于两个msg通道，一个发送，一个接收。 AddTwoInts.srv 文件位置：自定义srv文件 #对两个整数求和，虚线之上是输入量，之下是返回量 int32 a int32 b --- int32 sum Empty.srv 文件位置：std_srvs/Empty.srv #代表一个空的srv类型 --- GetMap.srv 文件位置:nav_msgs/GetMap.srv #获取地图，注意请求部分为空 --- nav_msgs/OccupancyGrid map GetPlan.srv 文件位置:nav_msgs/GetPlan.srv #得到一条从当前位置到目标点的路径 geometry_msgs/PoseStamped start #起始点 geometry_msgs/PoseStamped goal #目标点 float32 tolerance #到达目标点的x，y方向的容错距离 --- nav_msgs/Path plan SetBool.srv 文件位置：std_srvs/SetBools.srv bool data # 启动或者关闭硬件 --- bool success # 标示硬件是否成功运行 string message # 运行信息 SetCameraInfo.srv 文件位置:sensor_msgs/SetCameraInfo.srv #通过给定的CameraInfo相机信息，来对相机进行标定 sensor_msgs/CameraInfo camera_info #相机信息 --- bool success #如果调用成功，则返回true string status_message #给出调用成功的细节 SetMap.srv 文件位置：nav_msgs/SetMap.srv #以初始位置为基准，设定新的地图 nav_msgs/OccupancyGrid map geometry_msgs/PoseWithCovarianceStamped initial_pose --- bool success TalkerListener.srv #文件位置: 自定义srv文件 --- bool success # 标示srv是否成功运行 string message # 信息，如错误信息等 Trigger.srv 文件位置:std_srvs/Trigger.srv --- bool success # 标示srv是否成功运行 string message # 信息，如错误信息等 "},"Chapter3/parameter_server.html":{"url":"Chapter3/parameter_server.html","title":"第七章 parameter_server","keywords":"","body":"Parameter Server 参数服务器 简介 严格来说，param并不能称作一种通信方式，因为它往往只是用来存储一些静态的设置，而不是动态变化的。所以关于param的操作非常轻巧，非常简单。 前文介绍了ROS中常见的两种通信方式——主题和服务，这节介绍另外一种通信方式——参数服务器（parameter server）。与前两种通信方式不同，参数服务器也可以说是特殊的“通信方式”。特殊点在于参数服务器是节点存储参数、配置参数以及全局共享参数的地方。参数服务器使用互联网传输，在节点管理器中运行，实现整个通信过程。 参数服务器，作为ROS中另外一种数据传输方式，有别于topic和service，它更加的静态。参数服务器维护着一个数据字典，字典里存储着各种参数和配置。 字典简介 字典，其实就是一个个的键值对(key:value)。与C++中的map,或者python中的dict相似。我们小时候学习语文的时候，常常都会有一本字典，当遇到不认识的字，我们可以通过查拼音找到这个字，获取这个字的读音、意义等等。这里的字典可以对比理解记忆。 每一个key不重复，且每一个key对应着一个value。也可以说字典就是一种映射关系，在实际的项目应用中，因为字典的这种静态的映射特点，我们往往将一些不常用到的参数和配置放入参数服务器的字典里，这样对这些数据进行读写都更加方便高效。 维护方式 参数服务器的维护方式非常的简单灵活，总的来讲有三种方式： 命令行维护 launch文件内读写 node源码 下面一一介绍这三种维护方式。 命令行维护 使用命令行来维护参数服务器，主要使用rosparam语句来进行操作的各种命令，如下表： rosparam 命令 作用 rosparam set param_key param_value 设置参数 rosparam get param_key 显示参数 rosparam load file_name 从文件加载参数 rosparam dump file_name 保存参数到文件 rosparam delete 删除参数 rosparam list 列出参数名称 load&&dump文件 load和dump文件需要遵守YAML格式，YAML格式具体示例如下： name:'Zhangsan' age:20 gender:'M' score{Chinese:80,Math:90} score_history:[85,82,88,90] 简明解释,就是 “名称+：+值” 这样一种常用的解释方式。 一般格式：key : value 遵循格式进行定义参数。其实就可以把YAML文件的内容理解为字典，因为它也是键值对的形式。 操作示例 首先打开模拟场景roslaunch robot_sim_demo robot_spawn.launch 输入rosparam list查看参数服务器上的paramrosparam list 如图： 查询参数信息，例如查询竖直方向重力参数。输入rosparam get /gazebo/gravity_z回车得到参数值rosparam get /gazebo/gravity_z 如图： 尝试保存一个参数到文件。输入rosparam dump param.yaml 之后，就可以在当前路径看到该文件，也就能打开去查看到相关的参数信息rosparam dump param.yaml 如图： "},"Chapter3/action.html":{"url":"Chapter3/action.html","title":"第八章 action","keywords":"","body":"action 动作 简介 actionlib是ROS中一个很重要的库，类似service通信机制，actionlib也是一种请求——响应机制的通信方式。 actionlib主要弥补了service通信的一个不足：就是当机器人执行一个比较耗时的任务时，假如利用service通信方式，那么client会很长时间接受不到反馈，致使通信受阻。 当service通信不能很好的完成任务的时候，使用actionlib则可以更好地实现长时间的通信过程。actionlib通信过程可以随时查看过程进度，也可以终止请求。这样的一个特性，使得actionlib在一些特别的机制中拥有很高的效率。 原理 action的工作原理是client-server模式，也是一个双向的通信模式。通信双方在ROS action Protocol下通过消息进行数据的交流通信。client和server为用户提供一个简单的API来请求目标（在客户端）或通过函数调用和回调来执行目标（在服务器端）。 通信的双方在ROS action Protocal下进行通信，是通过接口来实现的，如下图： 我们可以看到,客户端可以向服务器发送目标指令或取消动作指令,而服务器则可以给客户端发送实时的状态信息,结果信息,反馈信息等,从而完成了service没法做到的功能。 action规范 利用动作库进行请求响应，actoin的内容格式包含三个部分:目标、结果、反馈。 目标机器人执行一个动作，应该有明确的移动目标信息，包括一些参数的设定，方向、角度、速度等等。从而使机器人完成动作任务。 结果当运动完成时，action服务器把本次运动的结果数据发送给客户端，使客户端得到本次动作的全部信息，例如可能包含机器人的运动时长，最终姿势等等。 反馈在动作进行的过程中，应该有实时的状态信息反馈给服务器的实施者(client)，告诉实施者动作完成的状态，可以使实施者作出准确的判断去修正命令。 规范格式如下： # Define the goal uint32 dishwasher_id # Specify which dishwasher we want to use --- # Define the result uint32 total_dishes_cleaned --- # Define a feedback message float32 percent_complete 添加依赖和生成文件 写完之后修改文件夹里CmakeLists.txt如下内容: find_package(catkin REQUIRED genmsg actionlib_msgs actionlib) add_action_files(DIRECTORY action FILES DoDishes.action) generate_messages(DEPENDENCIES actionlib_msgs) add_action_files(DIRECTORY action FILES Handling.action) generate_messages( DEPENDENCIES actionlib_msgs) 修改package.xml,添加所需要的依赖如下: actionlib actionlib_msgs actionlib actionlib_msgs 然后回到工作空间 catkin_ws进行编译。 catkin_make 常用action类型 介绍常见的action类型以及其定义 AddTwoInts.action 文件位置:自定义action文件 #表示将两个整数求和 int64 a int64 b --- int64 sum --- AutoDocking.action 文件位置:自定义action文件 #goal --- #result string text --- #feedback string state string text GetMap.action 文件位置:nav_msgs/GetMap.action #获取地图信息 --- nav_msgs/OccupancyGrid map --- #feedback无部分 MoveBase.action 文件位置:geometry_msgs/MoveBase.action geometry_msgs/PoseStamped target_pose --- --- geometry_msgs/PoseStamped base_position "},"Chapter4/Introduction.html":{"url":"Chapter4/Introduction.html","title":"第四章 ROS常用开发工具","keywords":"","body":"Chapter 4 Introduction ROS中的工具就是帮助我们完成一系列的操作，使得我们的工作更加轻松高效。ROS工具的功能大概有以下几个方向：仿真、调试、可视化。ROS开发时常使用的工具，分别是： Gazebo RViz rqt rosbag rosbridge moveit! 这六个工具是开发时常使用到的工具。 gazebo是最常用的一种ROS仿真工具，也是目前仿真ROS效果最好的工具； RViz是可视化工具，能将接收到的信息呈现出来； rqt则是非常好用的数据流可视化工具，有了它我们可以直观的看到消息的通信架构和流通路径； rosbag则是对软件包进行操作的一个命令，此外还提供代码API，对包进行操作编写； rosbridge是一个沟通ROS和外界的功能包， moveit!是目前为止应用最广泛的开源操作软件。 好好学习本章，熟练使用这几款工具对于我们的ROS学习和开发都有极大的好处，可以事半功倍。 "},"Chapter4/gazebo.html":{"url":"Chapter4/gazebo.html","title":"第一篇 gazebo","keywords":"","body":"gazebo gazebo实现仿真的功能。 Gazebo是一个机器人仿真工具，模拟器，也是一个独立的开源机器人仿真平台。当今市面上还有其他的仿真工具例如V—Rep、Webots等等。但是Gazebo不仅开源，也是兼容ROS最好的仿真工具。 Gazebo的功能很强大，最大的优点是对ROS的支持很好，因为Gazebo和ROS都由OSRF（Open Source Robotics Foundation）开源机器人组织来维护。Gazebo支持很多开源的物理引擎，比如最典型的ODE。可以进行机器人的运动学、动力学仿真，能够模拟机器人常用的传感器（如激光雷达、摄像头、IMU等），也可以加载自定义的环境和场景。 仿真的意义 仿真不仅仅只是做出一个很酷的3D场景，更重要的是给机器人一个逼近现实的虚拟物理环境，比如光照条件、物理距离等等。设定好具体的参数，让机器人完成我们设定的目标任务。比如一些有危险因素的测试，就可以让机器人在仿真的环境中去完成，例如无人车在交通环境复杂的交通要道的效果，我们就可以在仿真的环境下测试各种情况无人车的反应与效果，如车辆的性能、驾驶的策略、车流人流的行为模式等，又或者各种不可控因素如雨雪天气，突发事故，车辆故障等，从而收集结果参数指标信息等等，只有更大程度的逼近现实，才能得出车辆的真实效果。直到无人车在仿真条件下做到万无一失，才能放心的投放到真实环境中去使用。这样即避免了危险因素对实验者的威胁，也节约了时间和资源，这就是仿真的意义。 通常一些不依赖于具体硬件的算法和场景都可以在Gazebo上仿真。例如图像识别、传感器数据融合处理、路径规划、SLAM等任务完全可以在Gazebo上仿真实现，大大减轻了对硬件的依赖。 操作说明 和我们前面的实例测试一样，我们打开教材的模拟场景 roslaunch robot_sim_demo robot_spawn_launch 对地图的操作方式： 平移：鼠标左键 旋转：鼠标滚轮中键 放缩：鼠标滚轮 界面左侧是控制面板 导入模型就在控制面板的insert,可以直接拖入模拟空间，也可以按需自制模型拖入。 "},"Chapter4/RViz.html":{"url":"Chapter4/RViz.html","title":"第二篇 RViz","keywords":"","body":"RViz RViz(the Robit Visualization tool)机器人可视化工具。可视化的作用是直观的显示出图像、雷达等信息，它极大的方便了监控和调试等操作。 Gazebo是一个机器人仿真工具，模拟器，也是一个独立的开源机器人仿真平台。当今市面上还有其他的仿真工具例如V—Rep、Webots等等。但是Gazebo不仅开源，也是兼容ROS最好的仿真工具。 Gazebo的功能很强大，最大的优点是对ROS的支持很好，因为Gazebo和ROS都由OSRF（Open Source Robotics Foundation）开源机器人组织来维护。Gazebo支持很多开源的物理引擎，比如最典型的ODE。可以进行机器人的运动学、动力学仿真，能够模拟机器人常用的传感器（如激光雷达、摄像头、IMU等），也可以加载自定义的环境和场景。 操作说明 和我们前面的实例测试一样，我们打开教材的模拟场景roslaunch robot_sim_demo robot_spawn_launch 打开一个新的终端，并输入rviz,就可以打开RViz工具了rviz 对地图的操作方式： 平移：鼠标滚轮中键 旋转：鼠标左键 放缩：鼠标滚轮 界面左侧是控制面板，可以添加插件 RViz的插件种类繁多功能强大，非常适合我们开发调试ROS程序。 gazebo与RViz 虽然从界面上来看，RViz和Gazebo非常相似，但实际上两者有着很大的不同。Gazebo实现的是仿真，提供一个虚拟的世界；RViz实现的是可视化，呈现接收到的信息，左侧的插件相当于是一个个的subscriber。RViz接收信息，并且显示。所以RViz和Gazebo有本质的差异。 "},"Chapter4/rqt.html":{"url":"Chapter4/rqt.html","title":"第三篇 rqt","keywords":"","body":"rqt rqt是一个基于qt开发的可视化工具，拥有扩展性好、灵活易用、跨平台等特点，主要作用和RViz一致都是可视化，但是和RViz相比，rqt要高级一个层次。 操作命令 rqt_graph :显示通信架构 rqt_plot ：绘制曲线 rqt_console ：查看日志 rqt_graph rqt_graph是来显示通信架构，也就是我们上一章所讲的内容节点、主题等等，当前有哪些Node和topic在运行，消息的流向是怎样，都能通过这个语句显示出来。此命令由于能显示系统的全貌，所以非常的常用。 rqt_plot rqt_plot将一些参数，尤其是动态参数以曲线的形式绘制出来。当我们在开发时查看机器人的原始数据，我们就能利用rqt_plot将这些原始数据用曲线绘制出来，非常的直观，利于我们分析数据。 rqt_console rqt_console里存在一些过滤器，我们可以利用它方便的查到我们需要的日志。 实例测试 首先打开我们教材的模拟场景，输入roslaunch robot_sim_demo robot_spawn_launch 输入命令语句rqt_graph,显示出了当前环境下运行的Node和topic，十分直观的看到通信结构以及消息流向。注意在椭圆形的代表节点，矩形代表topic。 输入命令语句rqt_plot,显示出曲线坐标窗口，在上方输入框里添加或者删除topic，比如我们查看速度，可以在框里设置好topic后，移动机器人，就可以看到自动绘制的线速度或者角速度曲线。 输入命令语句rqt_console，显示日志的输出，配合rqt_logger_level查看日志的级别。 小结 rqt_graph这个功能是强大的，它使得我们初学者可以直观的看到ROS的通信架构和信息流，方便我们理解的同时，也使得我们能够最快的纠错等等。rqt_plot绘制数据曲线图，也是极大的帮助我们了解数据的变化态势，理解数据流的作用，用曲线来显示我们的操作，精确直观。rqt_console配合rqt_logger_level，查看日志，对于查找错误和DeBug都有很大帮助。 "},"Chapter4/rosbag.html":{"url":"Chapter4/rosbag.html","title":"第四篇 rosbag","keywords":"","body":"rosbag rosbag是一套用于记录和回放ROS topic(主题)的工具。它旨在提高性能，并避免消息的反序列化和重新排序。rosbag package提供了命令行工具和代码API，可以用C++或者python来编写包。而且rosbag命令行工具和代码API是稳定的，始终保持向后的兼容性。 操作命令 rosbag对软件包来操作，一个包是ROS用于存储ROS消息数据的文件格式，rosbag命令可以记录、回放和操作包。指令列表如下： 命令 作用 cheak 确定一个包是否可以在当前系统中进行，或者是否可以迁移。 decompress 压缩一个或多个包文件。 filter 解压一个或多个包文件。 fix 在包文件中修复消息，以便在当前系统中播放。 help 获取相关命令指示帮助信息 info 总结一个或多个包文件的内容。 play 以一种时间同步的方式回放一个或多个包文件的内容。 record 用指定主题的内容记录一个包文件。 reindex 重新索引一个或多个包文件。 小结 rosbag通过命令行能够对软件包进行很多的操作，更重要的拥有代码API，可以对包进行重新编写。增加一个ROS API，用于通过服务调用与播放和录制节点进行交互。 "},"Chapter4/rosbridge.html":{"url":"Chapter4/rosbridge.html","title":"第五篇 rosbridge","keywords":"","body":"Rosbridge Rosbridge是一个用在ROS系统和其他系统之间的一个功能包,就像是它的名字一样,起到一个\"桥梁\"的作用,使得ros系统和其他系统能够进行交互.Rosbridge为非ROS程序提供了一个JSON API,有许多与Rosbridge进行交互的前端，包括一个用于Web浏览器交互的WebSocket服务器。Rosbridge_suite是一个包含Rosbridge的元程序包，用于Rosbridge的各种前端程序包（如WebSocket程序包）和帮助程序包。 协议和实现 Rosbridge主要包含两部分内容:协议(Potocol)和实现(Implementation) 协议 Ｒosbridge Protocol提供了非ROS程序与ROS通信的具体的格式规范，规范基于JSON格式,包括订阅topic，发布message,调用server，设置参数，压缩消息等等．例如订阅topic的格式规范如下： { \"op\": \"subscribe\", \"topic\": \"/cmd_vel\", \"type\": \"geometry_msgs/Twist\" } 此规范与所用的编程语言和传输方式无关，任何可以发送JSON格式的语音和传输方式都可以Rosbridge protocol进行交流，并且与ROS进行交互． 实现 Rosbridge_suite元程序包是实现Ｒosbridge　Protocol并提供WebSocket传输层的包的集合。 这些软件包包括： Rosbridge_library : 核心rosbridge软件包。Rosbridge_library负责获取JSON字符串并将命令发送到ROS，反过来接收处理ROS发过来的信息，将之转换为JSON字符串，并将结果转交给非ROS程序。 rosapi : 通过服务调用来访问某些ROS操作，这些服务通常为ROS客户端库保留的服务．这些操作包括获取和设置参数，获取主题列表等等。 rosbridge_server : 虽然Rosbridge_library提供JSON到ROS转换，但它将传输层留给其他人。Rosbridge_server提供了一个WebSocket连接，所以浏览器可以与ROS“交谈”。Roslibjs是一个浏览器的JavaScript库，可以通过rosbridge_server与ROS进行交流。 源码 安装与使用 安装 Rosbridge是基于ROS的，首先要确保自己正确的安装完成了ROS之后可以启动终端执行命令： sudo apt-get install ros- -rosbridge-server 中间的rosdistro为自己的ROS版本，依照自己的版本进行安装． 使用 关于更深入的使用，可以参考本课程的视频课程，简单的入门使用可以参考链接如下： 链接 "},"Chapter4/moveit.html":{"url":"Chapter4/moveit.html","title":"第六篇 moveit","keywords":"","body":"moveit! 官方网站 2012年，一款叫做moveit!的移动操作软件诞生了，moveit！最初在Willow Garage由Sachin Chitta，Ioan Sucan，Gil E. Jones，Acorn Pooley，Suat Gedikli，Dave Hershberger开发，它融合了研究者在运动规划、操纵、3D感知、运动学、控制和导航方面的最新进展，为操作者提供了一个易于使用的平台，使用它可以开发先进的机器人应用，也被广泛应用于工业，商业，研发和其他领域。由于以上特性，moveit！一跃成为在机器人上最广泛使用的开源操作软件，截止2017年，已经被用于超过65台机器人。 moveit!视频链接 使用 moveit!的使用通过为用户提供接口来调用它，包括C++、Python、GUI三种接口。ROS中的 move_group节点充当整合器，整合多个独立组件，提供ROS风格的Action和service。move_group通过ROS topic和action与机器人通讯，获取机器人的位置、节点等状态，获取数据再传递给机器人的控制器。 move_group节点获取到节点状态信息或者机器人变换信息时候，会通过控制器的接口去处理这些信息，比如进行坐标转换、规划场景、3D感知。另外，move_group的结构比较容易扩展，不仅具有独立的能力如抓放，运动规划，也可扩展自公共类，但实际作为独立的插件运行。moveit!系统结构图如下： "},"Chapter5/Introduction.html":{"url":"Chapter5/Introduction.html","title":"第五章 roscpp编程代码","keywords":"","body":"Chapter 5 Introduction 从本章开始，我们就要正式的接触ROS编程了。在之前的章节，了解到用命令行启动ROS程序、发送指令消息，或使用可视化界面来调试机器人。你可能很想知道，这些工具到底是如何实现这些功能的。其实这些工具本质上都是基于ROS的客户端库（Client Libarary）实现的。所谓客户端库，简单的理解就是一套编程接口，ROS为我们机器人开发者提供了不同语言的接口，比如roscpp是C++语言ROS接口；rospy是python语言的ROS接口，我们直接调用它所提供的函数就可以实现topic、service等通信功能。 本章我们介绍roscpp，roscpp的基本函数，学习用C++开发ROS的基本方法。本章的内容需要有C++的基础，如果你对C++比较陌生，建议先学习C++编程。 "},"Chapter5/ClientLibrary和roscpp.html":{"url":"Chapter5/ClientLibrary和roscpp.html","title":"第一篇 ClientLibrary和roscpp","keywords":"","body":"Client library和roscpp Client library ROS为机器人开发者们提供了不同语言的编程接口，比如C++接口叫做roscpp，Python接口叫做rospy，Java接口叫做rosjava。尽管语言不通，但这些接口都可以用来创建topic、service、param，实现ROS的通信功能。Clinet Lirary有点类似开发中的Helper Class，把一些常用的基本功能做了封装。 目前ROS支持的Clinet Library包括： Client Library 介绍 roscpp ROS的C++库，是目前最广泛应用的ROS客户端库，执行效率高 rospy ROS的Python库，开发效率高，通常用在对运行时间没有太大要求的场合，例如配置、初始化等操作 roslisp ROS的LISP库 roscs Mono/.NET.库，可用任何Mono/.NET语言，包括C#，Iron Python， Iron Ruby等 rosgo ROS Go语言库 rosjava ROS Java语言库 rosnodejs Javascript客户端库 ... ... 目前最常用的只有roscpp和rospy，而其余的语言版本基本都还是测试版。 从开发客户端库的角度看，一个客户端库，至少需要能够包括master注册、名称管理、消息收发等功能。这样才能给开发者提供对ROS通信架构进行配置的方法。整个ROS包括的packages如下，你可以看到roscpp、rospy处于什么位置。 roscpp roscpp is a C++ implementation of ROS. It provides a client library that enables C++ programmers to quickly interface with ROS Topics, Services, and Parameters. roscpp is the most widely used ROS client library and is designed to be the high-performance library for ROS. roscpp位于/opt/ros/kinetic之下，用C++实现的ROS功能库。在ROS中，C++的代码是通过catkin这个编译系统（扩展的CMake）来进行编译构建的。所以简单地理解，你也可以把roscpp就当作为一个C++的库，我们创建一个CMake工程，在其中include了roscpp等ROS的libraries，这样就可以在工程中使用ROS提供的函数了。 通常我们要调用ROS的C++接口，首先就需要#include 。 roscpp的主要部分包括： ros::init() : 解析传入的ROS参数，创建node第一步需要用到的函数 ros::NodeHandle : 和topic、service、param等交互的公共接口 ros::master : 包含从master查询信息的函数 ros::this_node：包含查询这个进程(node)的函数 ros::service：包含查询服务的函数 ros::param：包含查询参数服务器的函数，而不需要用到NodeHandle ros::names：包含处理ROS图资源名称的函数 具体可见：http://docs.ros.org/api/roscpp/html/index.html 以上功能可以分为以下几类： Initialization and Shutdown 初始与关闭 Topics 话题 Services 服务 Parameter Server 参数服务器 Timers 定时器 NodeHandles 节点句柄 Callbacks and Spinning 回调和自旋（或者翻译叫轮询） Logging 日志 Names and Node Information 名称管理 Time 时钟 Exception 异常 看到这么多接口，千万别觉得复杂，我们日常开发并不会用到所有的功能，你只需对经常使用的有一些印象，掌握几个比较常见和重要的用法就足够了。 "},"Chapter5/节点初始、关闭以及NodeHandle.html":{"url":"Chapter5/节点初始、关闭以及NodeHandle.html","title":"第二篇 节点初始、关闭以及NodeHandle","keywords":"","body":"节点初始、关闭以及NodeHandle 当执行一个ROS程序，程序被加载到内存中，就成为了一个进程。在ROS里叫做节点。每一个ROS的节点尽管功能不同，但都有必不可少的一些步骤，比如初始化、销毁，需要通行的场景通常都还需要节点的句柄。 这一篇我们来学习Node(节点)最基本的一些操作。 初始化节点 对于一个C++写的ROS程序，之所以它区别于普通C++程序，是因为代码中做了两层工作： 调用了ros::init()函数，从而初始化节点的名称和其他信息，一般我们ROS程序一开始都会以这种方式开始。 创建ros::NodeHandle对象，也就是节点的句柄，它可以用来创建Publisher、Subscriber以及做其他事情。 句柄(Handle)这个概念可以理解为一个“把手”。你握住了门把手，就可以很容易把整扇门拉开，而不必关心门是什么样子。NodeHandle就是对节点资源的描述，有了它你就可以操作这个节点的各种信息和动作，比如为程序提供服务、监听某个topic上的消息、访问和修改param等等。 关闭节点 通常我们要关闭一个节点可以直接在终端上按Ctrl+C，系统会自动触发SIGINT句柄来关闭这个进程。你也可以通过调用ros::shutdown()来手动关闭节点，但通常我们很少这样做。 以下是一个节点初始化、关闭的例子: #include int main(int argc, char** argv) { ros::init(argc, argv, \"your_node_name\"); ros::NodeHandle nh; //....节点功能 //.... ros::spin();//用于触发topic、service的响应队列 return 0; } 这段代码是最常见的一个ROS程序的执行步骤。通常要先启动节点，获取句柄。而关闭的工作系统自动帮我们完成，如果有特殊需要你也可以自定义。你可能很关心句柄可以用来做些什么，接下来我们来看看NodeHandle常用的成员函数。 NodeHandle常用成员函数 NodeHandle是Node的句柄，用来对当前节点进行各种操作。在ROS中，NodeHandle是roscpp已经定义好的一个类，通过引用 include ，我们可以创建这个类，以及使用它的成员函数。NodeHandle常用成员函数包括： //创建话题的publisher ros::Publisher advertise(const string &topic, uint32_t queue_size, bool latch=false); //第一个参数为发布话题的名称 //第二个是消息队列的最大长度，如果发布的消息超过这个长度而没有被接收，那么旧的消息就会出队。(先进先出原则)通常设为一个较小的数即可。 //第三个参数是是否锁存。某些话题并不是会以某个频率发布，比如/map这个topic，只有在初次订阅或者地图更新这两种情况下，/map才会发布消息。这里就用到了锁存。 //创建话题的subscriber ros::Subscriber subscribe(const string &topic, uint32_t queue_size, void(*)(M)); //第一个参数是订阅话题的名称 //第二个参数是订阅队列的长度，如果受到的消息都没来得及处理，那么新消息入队，旧消息就会出队(先进先出原则) //第三个参数是回调函数指针，指向回调函数入口地址，以此来处理接收到的消息 //创建服务的server，提供服务 ros::ServiceServer advertiseService(const string &service, bool(*srv_func)(Mreq &, Mres &)); //第一个参数是service名称 //第二个参数是服务函数的指针，指向服务函数。指向的函数应该有两个参数，分别接受请求和响应。 //创建服务的client ros::ServiceClient serviceClient(const string &service_name, bool persistent=false); //第一个参数是service名称 //第二个参数用于设置服务的连接是否持续，如果为true，client将会保持与远程主机server的连接，这样后续的请求会快一些。通常我们设为flase //查询某个参数的值 bool getParam(const string &key, std::string &s); bool getParam (const std::string &key, double &d) const； bool getParam (const std::string &key, int &i) const； //从参数服务器上获取key对应的值，已重载了多个类型 //给参数赋值 void setParam (const std::string &key, const std::string &s) const； void setParam (const std::string &key, const char *s) const; void setParam (const std::string &key, int i) const; //给key对应的val赋值，重载了多个类型的val 可以看出，NodeHandle对象在ROS C++程序里非常重要。各种类型的通信都需要用NodeHandle来创建完成。下面我们具体来看看topic、service和param这三种基本通信方式的写法。 "},"Chapter5/topic_demo.html":{"url":"Chapter5/topic_demo.html","title":"第三篇 topic_demo","keywords":"","body":"topic_demo Topic是ROS里一种异步通信的模型。一般是节点间分工明确，有的节点只负责发送，有的节点只负责接收处理。对于绝大多数的机器人应用场景，比如传感器数据收发，速度控制指令的收发，Topic模型是最适合的通信方式。 为了讲明白topic通信的编程思路，我们首先来看topic_demo中的代码,这个程序是一个消息收发的例子：自定义一个类型为gps的消息（包括位置x，y和工作状态state信息），一个node以一定频率发布模拟的gps消息，另一个node接收并处理，算出到原点的距离。 第一步 创建gps消息 在代码中，我们会用到自定义类型的gps消息，因此就需要来自定义gps消息，在msg路径下创建gps.msg： 见topic_demo/msg/gps.msg string state #工作状态 float32 x #x坐标 float32 y #y坐标 以上就定义了一个gps类型的消息，你可以把它理解成一个C语言中的结构体，类似于 struct gps { string state; float32 x; float32 y; } 注意到了没，gps.msg文件的文件名称就是结构体的名称。 在程序中对一个gps消息进行创建修改的方法和对结构体的操作一样。接下来，还有关键的一步：我们要确保msg文件被转换成为C++，Python和其他语言的源代码：当你创建完了msg文件，记得修改CMakeLists.txt和package.xml，从而让系统能够编译自定义消息。 在package.xml文件中需要改动确保它包含以下两条语句: message_generation message_runtime 如果没有，添加进去。 注意，在构建的时候，我们只需要\"message_generation\"。然而，在运行的时候，我们需要\"message_runtime\"。 在 CMakeLists.txt文件中需要改动利用find_packag函数，增加对message_generation的依赖，这样就可以生成消息了。你可以直接在COMPONENTS的列表里增加message_generation，就像这样： find_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs message_generation ) 注：有时候你会发现，即使你没有调用find_package,你也可以编译通过。这是因为catkin把你所有的package都整合在一起。因此，如果其他的package调用了find_package，你的package的依赖就会是同样的配置。但是，在你单独编译时，忘记调用find_package会很容易出错。 同样，你需要确保你设置了运行时依赖： catkin_package( ... CATKIN_DEPENDS message_runtime ... ...) 接着，找到如下代码块: # add_message_files( # FILES # Message1.msg # Message2.msg # ) 去掉注释符号#，用你的.msg文件替代Message*.msg，就像下边这样： add_message_files( FILES gps.msg ) 接下来，找到如下部分: # generate_messages( # DEPENDENCIES # # std_msgs # Or other packages containing msgs # ) 去掉注释符号#，并附加上所有你消息文件所依赖的那些含有.msg文件的package（这个例子非常简单，只依赖std_msgs,不用添加roscpp,rospy)，结果如下: generate_messages( DEPENDENCIES std_msgs ) 修改后的CMakeLists.txt文件 find_package(catkin REQUIRED COMPONENTS roscpp std_msgs message_generation #需要添加的地方 ) ## Generate messages in the 'msg' folder add_message_files( FILES gps.msg ) #catkin在cmake之上新增的命令，指定从哪个消息文件生成 ## Generate added messages and services with any dependencies listed here generate_messages( DEPENDENCIES std_msgs ) #catkin新增的命令，用于生成消息 #DEPENDENCIES后面指定生成msg需要依赖其他什么消息，由于gps.msg用到了flaot32这种ROS标准消息类型，因此需要再把std_msgs作为依赖 catkin_package( # INCLUDE_DIRS include # LIBRARIES publish_subscribe_demo CATKIN_DEPENDS roscpp rospy std_msgs message_runtime # DEPENDS system_lib ) 修改后的package.xml文件 与 作用相同 catkin message_generation roscpp rospy std_msgs roscpp rospy std_msgs message_runtime 由于增加了新的消息，所以我们需要重新编译我们的package： # In your catkin workspace catkin_make 编译完成之后会在工作空间的devel路径下生成gps.msg对应的头文件gps.h。头文件是按照C++的语法规则定义了topic_demo::gps类型的数据。 第二步 消息发布节点代码 talker.cpp 注：要在代码中使用自定义消息类型，只要#include 就行了。 定义完了消息，就可以开始写ROS代码了。通常我们会把消息收发的两端分成两个节点来写，一个节点就是一个完整的C++程序。talker.cpp //ROS头文件 #include //自定义msg产生的头文件 #include int main(int argc, char **argv) { //用于解析ROS参数，第三个参数为本节点名 ros::init(argc, argv, \"talker\"); //实例化句柄，初始化node ros::NodeHandle nh; //自定义gps msg topic_demo::gps msg; msg.x = 1.0; msg.y = 1.0; msg.state = \"working\"; //创建publisher ros::Publisher pub = nh.advertise(\"gps_info\", 1); //定义消息发布的频率 ros::Rate loop_rate(1.0); //循环发布msg while (ros::ok()) { //以指数增长，每隔1秒更新一次 msg.x = 1.03 * msg.x ; msg.y = 1.01 * msg.y; ROS_INFO(\"Talker: GPS: x = %f, y = %f \", msg.x ,msg.y); //以1Hz的频率发布msg pub.publish(msg); //根据前面定义的频率, sleep 1s loop_rate.sleep();//根据前面的定义的loop_rate,设置1s的暂停 } return 0; } 机器人上几乎所有的传感器，几乎都是按照固定频率发布消息这种方式来传输数据，只是发布频率和数据类型的区别。 第三步 消息接受节点代码 listener.cpp //ROS头文件 #include //包含自定义msg产生的头文件 #include //ROS标准msg头文件 #include //回调函数 void gpsCallback(const topic_demo::gps::ConstPtr &msg) { //计算离原点(0,0)的距离 std_msgs::Float32 distance; distance.data = sqrt(pow(msg->x,2)+pow(msg->y,2)); //float distance = sqrt(pow(msg->x,2)+pow(msg->y,2)); ROS_INFO(\"Listener: Distance to origin = %f, state: %s\",distance.data,msg->state.c_str()); } int main(int argc, char **argv) { ros::init(argc, argv, \"listener\"); ros::NodeHandle nh; ros::Subscriber sub = nh.subscribe(\"gps_info\", 1, gpsCallback); //ros::spin()用于调用所有可触发的回调函数。将进入循环，不会返回，类似于在循环里反复调用ros::spinOnce()。 ros::spin(); return 0; } 在topic接收方，有一个比较重要的概念，就是回调(CallBack)。在本例中，回调就是预先给gps_info话题传来的消息准备一个回调函数。事先定义好回调函数的操作，本例中是计算到原点的距离。只有当有消息来时，回调函数才会被触发执行。具体去触发的命令就是ros::spin()，它会反复的查看有没有消息来，如果有就会让回调函数去处理。 注：因此千万不要认为，只要指定了回调函数就会自动触发。你必须使用ros::spin()或者ros::spinOnce()才能真正使回调函数生效. 修改CMakeLists.txt文件 在CMakeLists.txt添加以下内容，生成可执行文件 add_executable(talker src/talker.cpp) #生成可执行文件talker add_dependencies(talker topic_demo_generate_messages_cpp) #表明在编译talker前，必须先编译完成自定义消息 #必须添加add_dependencies，否则找不到自定义的msg产生的头文件 target_link_libraries(talker ${catkin_LIBRARIES}) #链接 add_executable(listener src/listener.cpp ) #生成可执行文件listener add_dependencies(listener topic_demo_generate_messages_cpp) target_link_libraries(listener ${catkin_LIBRARIES})#链接 以上cmake语句告诉catkin编译系统如何去编译生成我们的程序。这些命令都是标准的cmake命令，如果不理解，请查阅cmake教程。 之后经过catkin_make，一个自定义消息+发布接收的基本模型就完成了。 第四步 运行方法 打开两个终端:一个运行: rosrun topic_demo talker 一个运行: rosrun topic_demo listener "},"Chapter5/spin.html":{"url":"Chapter5/spin.html","title":"第四篇 spin()与回调函数","keywords":"","body":"回调函数与spin()函数 回调函数在编程中是一种重要的方法，在维基百科上的解释是：In computer programming, a callback is any executable code that is passed as an argument to other code, which is expected to call back (execute) the argument at a given time.回调函数作为参数被传入到了另一个函数中（在本例中传递的是函数指针），在未来某个时刻（当有新的message到达），就会立即执行。Subscriber接收到消息，实际上是先把消息放到一个接受队列中去，如图所示。队列的长度在Subscriber构建的时候设置。当有spin函数执行，就会去处理消息队列中队首的消息。 spin具体处理的方法又可分为阻塞/非阻塞,单线程/多线程，在ROS函数接口层面我们有4种spin的方式： spin方法 是否阻塞 线程 ros::spin() 阻塞 单线程 ros::spinOnce() 非阻塞 单线程 ros::MultiThreadedSpin() 阻塞 多线程 ros::AsyncMultiThreadedSpin() 非阻塞 多线程 阻塞与非阻塞的区别我们已经讲了，下面来看看单线程与多线程的区别： 我们常用的spin()、spinOnce()是单个线程逐个处理回调队列里的数据。有些场合需要用到多线程分别处理，则可以用到MultiThreadedSpin()、AsyncMultiThreadedSpin()。 "},"Chapter5/service_demo.html":{"url":"Chapter5/service_demo.html","title":"第五篇 service_demo","keywords":"","body":"service_demo 在ROS中如何请求或者提供一个服务，我们来看service_demo的代码：一个节点发出服务请求（姓名，年龄），另一个节点进行服务响应，答复请求。 第一步 创建Greeting服务 创建service_demo/srv/Greeting.srv文件，内容包括： string name #短横线上方部分是服务请求的数据 int32 age --- #短横线下方是服务回传的内容。 string feedback 现在，你已经如前边所介绍的 在CMakeLists.txt文件中增加了对message_generation的依赖。: # Do not just add this line to your CMakeLists.txt, modify the existing line find_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs message_generation ) (对的, message_generation 对msg和srv都起作用) 同样，跟msg文件类似，你也需要在CMakeLists.txt文件中做一些修改。查看上边的说明，增加额外的依赖项。 删掉#，去除对下边语句的注释: # add_service_files( # FILES # Service1.srv # Service2.srv # ) 用你自己的srv文件名替换掉那些Service*.srv文件: add_service_files( FILES Greeting.srv ) 在package.xml文件中需要改动确保它包含以下两条语句: message_generation message_runtime 修改完之后，编译工作空间，生成Greeting.h文件新生成的Greeting类型的服务，其结构体的风格更为明显。可以这么理解，一个Greeting服务结构体中嵌套了两个结构体，分别是请求和响应：struct Greeting { struct Request { string name; int age; }request; struct Response { string feedback; }response; } 第二步 服务节点代码 server.cpp // This is the C++ version server file of the service demo // 加载必要文件，注意Service_demo的加载方式 # include \"ros/ros.h\" # include \"service_demo/Greeting.h\" # include \"string\" // 定义请求处理函数 bool handle_function(service_demo::Greeting::Request &req, service_demo::Greeting::Response &res) { // 此处我们对请求直接输出 ROS_INFO(\"Request from %s with age %d \", req.name.c_str(), req.age); // 返回一个反馈，将response设置为\"...\" res.feedback = \"Hi \" + req.name + \". I'm server!\"; return true; } int main(int argc, char **argv) { // 初始化节点，命名为\"greetings_server\" ros::init(argc, argv, \"greetings_server\"); // 定义service的server端，service名称为“greetings”，收到request请求之后传递给handle_function进行处理 ros::NodeHandle nh; ros::ServiceServer service = nh.advertiseService(\"greetings\", handle_function); ros::spin(); return 0; } 在以上代码中，服务的处理操作都写在handle_function()中，它的输入参数就是Greeting的Request和Response两部分，而非整个Greeting对象。通常在处理函数中，我们对Requst数据进行需要的操作，将结果写入到Response中。在roscpp中，处理函数返回值是bool型，也就是服务是否成功执行。不要理解成输入Request，返回Response，但是在rospy中是这样的。 第三步 请求节点代码 client.cpp //This is client of the service demo //包含必要文件，注意Service文件的包含方式，我们定义的srv文件为Greeting.srv, //catkin_make编译之后，生成的头文件Greeting.h //所以，在包含时需要写成Greeting.h # include \"ros/ros.h\" # include \"service_demo/Greeting.h\" int main(int argc, char **argv) { // 初始化，节点命名为\"greetings_client\" ros::init(argc, argv, \"greetings_client\"); // 定义service客户端，service名字为“greetings”，service类型为Service_demo ros::NodeHandle nh; ros::ServiceClient client = nh.serviceClient(\"greetings\"); // 实例化srv，设置其request消息的内容，这里request包含两个变量，name和age，见Greeting.srv service_demo::Greeting srv; srv.request.name = \"HAN\"; srv.request.age = 20; if (client.call(srv)) { // 注意我们的response部分中的内容只包含一个变量feedback， //另，注意将其转变成字符串 ROS_INFO(\"Response from server: %s\", srv.response.feedback.c_str()); } else { ROS_ERROR(\"Failed to call service Service_demo\"); return 1; } return 0; } 以上代码比较关键的地方有两处：一个是建立一个ServiceClient，另一个是开始调用服务。建立client需要用nh.serviceClient(\"greetings\")，指明服务的类型和服务的名称。而调用时可以直接用client.call(srv)，返回结果不是response，而是是否成功调用远程服务(bool型)。 CMakeLists.txt和pacakge.xml修改方法和topic_demo修改方法类似。 第四步 运行方法 启动服务器端 rosrun service_demo server 启动客户端 rosrun service_demo client "},"Chapter5/param_demo.html":{"url":"Chapter5/param_demo.html","title":"第六篇 patam_demo","keywords":"","body":"param_demo 关于param的API，roscpp为我们提供了两套，一套是放在ros::paramnamespace下，另一套是在ros::NodeHandle下，这两套API的操作完全一样，用哪一个取决于你的习惯。 第一步 param代码 以下是对param进行增删查改所有操作的方法，非常直观。 #include int main(int argc, char **argv){ ros::init(argc, argv, \"param_demo\"); ros::NodeHandle nh; int parameter1, parameter2, parameter3, parameter4, parameter5; //Get Param的三种方法 //① ros::param::get()获取参数“param1”的value，写入到parameter1上 bool ifget1 = ros::param::get(\"param1\", parameter1); //② ros::NodeHandle::getParam()获取参数，与①作用相同 bool ifget2 = nh.getParam(\"param2\",parameter2); //③ ros::NodeHandle::param()类似于①和② //但如果get不到指定的param，它可以给param指定一个默认值(如33333) nh.param(\"param3\", parameter3, 33333); if(ifget1) ROS_INFO(\"Get param1 = %d\", parameter1); else ROS_WARN(\"Didn't retrieve param1\"); if(ifget2) ROS_INFO(\"Get param2 = %d\", parameter2); else ROS_WARN(\"Didn't retrieve param2\"); if(nh.hasParam(\"param3\")) ROS_INFO(\"Get param3 = %d\", parameter3); else ROS_WARN(\"Didn't retrieve param3\"); //Set Param的两种方法 //① ros::param::set()设置参数 parameter4 = 4; ros::param::set(\"param4\", parameter4); //② ros::NodeHandle::setParam()设置参数 parameter5 = 5; nh.setParam(\"param5\",parameter5); ROS_INFO(\"Param4 is set to be %d\", parameter4); ROS_INFO(\"Param5 is set to be %d\", parameter5); //Check Param的两种方法 //① ros::NodeHandle::hasParam() bool ifparam5 = nh.hasParam(\"param5\"); //② ros::param::has() bool ifparam6 = ros::param::has(\"param6\"); if(ifparam5) ROS_INFO(\"Param5 exists\"); else ROS_INFO(\"Param5 doesn't exist\"); if(ifparam6) ROS_INFO(\"Param6 exists\"); else ROS_INFO(\"Param6 doesn't exist\"); //Delete Param的两种方法 //① ros::NodeHandle::deleteParam() bool ifdeleted5 = nh.deleteParam(\"param5\"); //② ros::param::del() bool ifdeleted6 = ros::param::del(\"param6\"); if(ifdeleted5) ROS_INFO(\"Param5 deleted\"); else ROS_INFO(\"Param5 not deleted\"); if(ifdeleted6) ROS_INFO(\"Param6 deleted\"); else ROS_INFO(\"Param6 not deleted\"); ros::Rate rate(0.3); while(ros::ok()){ int parameter = 0; ROS_INFO(\"=============Loop==============\"); //roscpp中尚未有ros::param::getallparams()之类的方法 if(ros::param::get(\"param1\", parameter)) ROS_INFO(\"parameter param1 = %d\", parameter); if(ros::param::get(\"param2\", parameter)) ROS_INFO(\"parameter param2 = %d\", parameter); if(ros::param::get(\"param3\", parameter)) ROS_INFO(\"parameter param3 = %d\", parameter); if(ros::param::get(\"param4\", parameter)) ROS_INFO(\"parameter param4 = %d\", parameter); if(ros::param::get(\"param5\", parameter)) ROS_INFO(\"parameter param5 = %d\", parameter); if(ros::param::get(\"param6\", parameter)) ROS_INFO(\"parameter param6 = %d\", parameter); rate.sleep(); } } 第二步 launch代码 设置参数在参数服务器上 通过两个标签我们设置好了5个param，从而在param的代码中进行增删查改的操作。 param3: 3 param4: 4 param5: 5 第三步 运行方法 执行以下命令之前，不需要提前运行roscore了。 roslaunch param_demo param_demo_cpp.launch "},"Chapter5/时钟与定时器.html":{"url":"Chapter5/时钟与定时器.html","title":"第七篇 时钟与定时器","keywords":"","body":"时钟与定时器 Time 与 Duration ROS里经常用到的一个功能就是时钟。比如计算机器人移动距离、设定一些程序的等待时间、设定计时器等等。roscpp同样给我们提供了时钟方面的操作。 具体来说，roscpp里有两种时间的表示方法，一种是时刻（ros::Time），一种是时段，时长（ros::Duration）。无论是Time还是Duration都具有相同的表示方法： int32 sec int32 nsec Time/Duration都由秒和纳秒组成。 要使用Time和Duration，需要#include 和#include Time和Duration表示的概念不相同，Time指的是某个时刻、时间点；而Duration指的是某个时段，尽管他们的数据结构都相同，但是用在不同的场景。 ROS为我们重载了Time、Duration类型之间的加减运算，比如: ros::Time begin = ros::Time::now(); //获取当前时间 ros::Time t1 = ros::Time::now() - ros::Duration(5.5); //t1是5.5s前的时刻，Time加减Duration返回都是Time ros::Time t2 = ros::Time::now() + ros::Duration(3.3);//t2是当前时刻往后推3.3s的时刻 ros::Duration d1 = t2 - t1;//从t1到t2的时长，两个Time相减返回Duration类型 ros::Duration d2 = d1 -ros::Duration(0,300);//两个Duration相减，还是Duration 以上是Time、Duration之间的加减运算，要注意没有Time+Time的做法。 sleep 通常在机器人任务执行中可能有需要等待的场景，这时就要用到sleep功能。roscpp中提供了两种sleep的方法： ros::Duration(0.5).sleep(); //用Duration对象的sleep方法休眠 ros::Rate r(10); //10HZ while(ros::ok()) { r.sleep(); //定义好sleep的频率，Rate对象会自动让整个循环以10hz休眠，即使有任务执行占用了时间 } Timer Rate的功能是指定一个频率，让某些动作按照这个频率来循环执行。与之类似的是ROS中的定时器Timer，它是通过设定回调函数和触发时间来实现某些动作的反复执行，创建方法和topic中的subscriber很像。 void callback1(const ros::TimerEvent&) { ROS_INFO(\"Callback 1 triggered\"); } void callback2(const ros::TimerEvent&) { ROS_INFO(\"Callback 2 triggered\"); } int main(int argc, char **argv) { ros::init(argc, argv, \"talker\"); ros::NodeHandle n; ros::Timer timer1 = n.createTimer(ros::Duration(0.1), callback1); //timer1每0.1s触发一次callback1函数 ros::Timer timer2 = n.createTimer(ros::Duration(1.0), callback2); //timer2每1.0s触发一次callback2函数 ros::spin(); //千万别忘了spin，只有spin了才能真正去触发回调函数 return 0; } "},"Chapter5/日志与异常.html":{"url":"Chapter5/日志与异常.html","title":"第八篇 日志与异常","keywords":"","body":"日志和异常 log ROS为开发者和用户提供了一套日志记录和输出系统。这套系统的实现方式是基于topic，也就是每个节点都会把一些日志信息发到一个统一的topic上去，这个topic就是/rosout。 rosout本身也是一个node，它专门负责进行日志的记录。我们在启动master的时候，系统就会附带启动rosout。 在roscpp中进行日志的输出，需要先引用include ,这个头文件包括了五个级别的日志输出接口，分别是： DEBUG INFO WARN ERROR FATAL 用法非常简单： ROS_DEBUG(\"The velocity is %f\", vel); ROS_WARN(\"Warn: the use is deprecated.\"); ROS_FATAL(\"Cannot start this node.\"); ... 当然也可以在一些特定场景，特定条件下输出，不过对于普通开发者来说可能用不到这么复杂的功能。具体可参考：http://wiki.ros.org/roscpp/Overview/Logging Exception roscpp中有两种异常类型，当有以下两种错误时，就会抛出异常： ros::InvalidNodeNameException当无效的节点名称传给ros::init(),通常是名称中有/,就会触发 ros::InvalidNameExcaption当无效名称传给了roscpp "},"Chapter6/Introduction.html":{"url":"Chapter6/Introduction.html","title":"第六章 tf与urdf","keywords":"","body":"Chapter 6 Introduction 机器人的坐标变换一直以来是机器人领域的一个难点。我们人类在进行一个简单的动作时，从思考到实施行动再到完成动作可能仅仅只需要几秒钟，但是对机器人来讲，就需要大量的计算和坐标转换。其中的坐标转换TF和URDF是本章要重点学习的内容。 首先我们从认识TF开始，然后学习TF消息和TF树，在后面我们还将介绍TF的数据类型和在C++以及Python中的一些函数和类。也将简单介绍统一机器人描述格式URDF。学习了TF和URDF，我们才算开始真正意义上的深入认识ROS。 "},"Chapter6/认识tf.html":{"url":"Chapter6/认识tf.html","title":"第一篇 认识tf","keywords":"","body":"认识TF TF是ROS世界里的一个基本的也是很重要的概念，所谓TF(TransForm)，就是坐标转换。在现实生活中，我们做出各种行为模式都可以在很短的时间里完成，比如拿起身边的物品。但是在机器人的世界里，则远远没有那么简单。观察下图，我们来分析机器人拿起身边的物品需要做到什么，而TF又起到什么样的作用。 观察这个机器人，我们直观上不认为拿起物品会又什么难度，站在人类的立场上，我们也许会想到手向前伸，抓住，手收回，就完成了这整个一系列的动作。但是如今的机器人远远没有这么智能，它能得到的只是各种传感器发送回来的数据，然后它再处理各种数据进行操作，比如手臂弯曲45度，再向前移动２０cm等这样的各种十分精确的动作。尽管如此，机器人依然没法做到像人类一样自如的进行各种行为操作。那么在这个过程中，TF又扮演着什么样的角色呢？还拿该图来说，当机器人的＂眼睛＂获取一组数据，关于物体的坐标方位，但是相对于机器人手臂来说，这个坐标只是相对于机器人头部的传感器，并不直接适用于机器人手臂执行，那么物体相对于头部和手臂之间的坐标转换操作，就是TF的作用。 坐标变换包括了位置和姿态两个方面的变换，ROS的tf是一个可以让用户随时记录多个坐标系的软件包。tf保持缓存的树形结构中的坐标系之间的关系，并且允许用户在任何期望的时间点在任何两个坐标系之间转换点，矢量等。 ROS中的tf tf可以被当做是一种标准规范。这套标准定义了坐标转换的数据格式和数据结构。tf本质是树状的数据结构，所以我们通常称之为\"tf tree\" 。 tf也可以看成是一个topic:/tf，话题中的message保存的就是tf tree的数据结构格式，维护了整个机器人的甚至是地图的坐标转换关系。tf还可以看成是一个package,它当中包含了很多的工具，比如可视化，查看关节间的tf,debug tf等等。tf含有一部分的接口，就是我们前面章节介绍的roscpp和rospy里关于tf的API。所以可以看成是话题转换的标准，话题，工具，接口。 观察上图，我们可以看到ROS数据结构的一个抽象图。ROS中机器人模型包含大量的部件，这些部件统称之为link。每一个link上面对应着一个frame, 即一个坐标系。link和frame概念是绑定在一起的。像上图pr2模型中我们可以看到有很多的frame,错综复杂的铺置在机器人的各个link上。维护各个坐标系之间的关系，就需要靠tf tree来处理，维护着各个坐标系之间的连通。如下图： 上图是我们常用的robot_sim_demo运行起来的tf　tree结构。每一个圆圈代表一个frame,对应着机器人上的一个link，任意的两个frame之间都必须是连通的。如果出现某一环的断裂，就会引发error，系统报错。所以完整的tf tree不能有任何断层的地方，这样我们才能查清楚任意两个frame之间的关系。仔细观察上图，我们发现每两个frame之间都有一个broadcaster,这就是为了使得两个frame之间能够正确连通，中间都会有一个Node(broadcaster)来发布消息。如果缺少Node来发布消息维护连通，那么这两个frame之间的连接就会断掉。broadcaster就是一个publisher,如果两个frame之间发生了相对运动，broadcaster就会发布相关消息．　 "}}