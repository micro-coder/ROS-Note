{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction ROS学习记录ROS版本：Kinetic系统：Ubuntu16.04 © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-07 17:59:03 "},"Chapter1/Introduction.html":{"url":"Chapter1/Introduction.html","title":"第一章 ROS基础搭建","keywords":"","body":"Chapter 1 Introduction 本章主要记录ROS的安装和配置过程 © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-07 17:59:02 "},"Chapter1/ROS安装.html":{"url":"Chapter1/ROS安装.html","title":"第一篇 ROS安装","keywords":"","body":"第一篇 ROS 安装 在安装之前，先要配置好Ubuntu的系统环境 打开System Settings -> Software & updates -> ubuntu software，全部都勾选,如图所示: 更改源为中国科学技术大学的镜像源 (使用国内的Ubuntu镜像源下载速度会更快些)，如图所示: 添加 sources.list(添加镜像源：科大源)sudo sh -c '. /etc/lsb-release && echo \"deb http://mirrors.ustc.edu.cn/ros/ubuntu/ `lsb_release -cs` main\" > /etc/apt/sources.list.d/ros-latest.list' ⑴. 点击下图红框中的链接，进入： ⑵. 粘贴下图的命令Command即可。 添加 Keys(公钥是Ubuntu的一种安全机制，也是ROS安装不可缺少的一步，第1步勾选的目的就是这个)sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 执行系统更新，更新源列表, 确保获得的ROS软件是最新的sudo apt update sudo apt upgrade 安装ROS包 ROS中有很多函数库和工具，官网提供了四种默认的安装方式，当然也可以单独安装某个特定的软件包。这四种方式包括桌面完整版安装、桌面版安装，基础版安装、单独软件包安装。推荐安装桌面完整版安装（包含ROS、rqt、rviz、通用机器人函数库、2D/3D仿真器、导航以及2D/3D感知功能），如下： 安装Kinetic版本的ROS(desktop-full : 桌面完整版)sudo apt-get install ros-kinetic-desktop-full 如果你不想安装桌面完整版，你还可以尝试以下三种方式安装： 桌面版安装（包含ROS、rqt、rviz以及通用机器人函数库）sudo apt-get install ros-kinetic-desktop 基础版安装（包含ROS核心软件包、构建工具以及通信相关的程序库，无GUI工具）sudo apt-get install ros-kinetic-ros-base 单独软件包安装（这种安装方式在运行ROS缺少某些package依赖时会经常用到。你可以安装某个指定的ROS软件包,使用软件包名称替换掉下面的PACKAGE）sudo apt-get install ros-kinetic-PACKAGE 例如系统提示找不到slam-gmapping，你就可以：sudo apt-get install ros-kinetic-slam-gmapping 要查找可用的软件包，请运行：apt-cache search ros-kinetic © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-07 17:59:02 "},"Chapter1/ROS配置.html":{"url":"Chapter1/ROS配置.html","title":"第二篇 ROS配置","keywords":"","body":"第二篇 ROS配置 ROS安装完成之后，我们还需要在自己电脑上对ROS进行一些参数的配置，使ROS能够正常工作。就像我们刚买到新手机一样，在开始使用之前，必须要做一些配置操作。 配置环境变量echo \"source /opt/ros/kinetic/setup.bash\" >> ~/.bashrc source ~/.bashrc 如果不配置，我们每打开新的终端terminal时，每次都要配置一次ROS的环境，不然ROS的命令不能正常使用。相反，将ROS环境变量添加到～/.bashrc文件中之后，我们每打开新的终端terminal时，系统每次都会自动把ROS环境变量配置好，ROS的命令就可以直接使用，很方便。 到目前为止，我们已经安装了运行核心ROS软件包所需的软件。为了创建和管理自己的ROS工作空间，我们还需要安装rosinstall工具，以及其依赖包：sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential rosinstall是ROS中一个独立的命令行工具包。通过一条命令就可以下载ROS的许多源代码。 初始化 rosdep sudo rosdep init 在使用ROS支持的工具或命令之前，需要初始化ROS。rosdep init会自动初始化ROS，并安装ROS运行必需的依赖文件。 更新 updaterosdep update 紧跟着就 update，更新此版本的ROS到最新的状态。并且不用sudo切换到管理员权限 至此，我们就完成了ROS的安装和配置工作，接下来就测试一下ROS能否正常工作吧。 首先启动ROS，运行 roscoreroscore 终端输出结果如图，就说明ROS能正常 启动： 然后运行ROS的吉祥物-小海龟，测试ROS的运行是否正常 重新打开一个新的终端，输入： rosrun turtlesim turtlesim_node 你就可以看到弹出一个新的窗口界面，一只小海龟出现在窗口里 　　　　　　 怎么操控这个小海龟呢？我们再重新打开一个终端，启动按键控制程序，输入命令： rosrun turtlesim turtle_teleop_key 接下来，我们运行在这个终端里，并通过键盘上的方向键，就可以控制小海龟的运动了。 至此，经过了上面的测试，ROS的安装、配置工作就已经全部完成了。 下面就可以正式开启ROS的学习之旅～～～ © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-07 17:59:02 "},"Chapter1/小结.html":{"url":"Chapter1/小结.html","title":"小结篇","keywords":"","body":"Chpaer 1 小结 在第一章的学习过程中，我们主要是完成了ROS的安装工作，工欲善其事，必先利其器。在学习的过程中，也是遇到了一些问题，对于还没入门的我来说，有的问题反复出现，解决的时间也很长。在此记录下来，以备日后查看。 第一章遇到的问题大都跟网络有关系，挂vpn可能会解决问题 1. 执行命令 sudo rosdep init出错 问题如图所示：　　　　 解决方法：这个问题的原因是raw.githubusercontent.com域名解释被污染了（你懂的...）。解决方法是到ipaddress.com上查询raw.githubusercontent.com的ip地址，然后在ubuntu的/etc/hosts文件上面加入这条域名解释就行了sudo vim /etc/hosts 注：查询到的IP地址不一定是下图所示 　　 2. 执行命令 rosdep update出错 问题如图所示：　　　 解决方法：主要是网络访问不稳定，只有多来几次。或者换成手机热点多试几次。 © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-07 17:59:02 "},"Chapter2/Introduction.html":{"url":"Chapter2/Introduction.html","title":"第二章 ROS学习基础","keywords":"","body":"Chapter 2 Introduction 本章开始正式学习ROS所用到的学习参考资料有：ROS-Academy-for-Beginners © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-07 17:59:02 "},"Chapter2/安装ROS-Beginners教学包.html":{"url":"Chapter2/安装ROS-Beginners教学包.html","title":"第一篇 学习资料源码下载","keywords":"","body":"安装ROS-Academy-for-Beginners教学包 这是我找到的算是比较系统的学习ROS入门的资料，目前关于ROS基础的学习资料比较少，所以网上资料也比较零散。我参考的这份学习资料对于我这个还没入门的人来说，很珍贵。所以我基本上参考这份资料进行学习，并记录自己在学习过程中遇到的问题和解决方法。 下载git因为我们需要从github上下载源代码，所以需要先安装git工具。ubuntu系统一般会自带git。sudo apt install git 然后，创建一个文件夹,作为ROS的工作空间workspace，名称随意，我这里命名为tutorial_ws mkdir tutorial_ws 并且在tutorial_ws文件夹下再创建一个子文件夹，这个子文件夹的名称不是随意的了，必须为srccd tutorial_ws mkdir src 接下来克隆github上的教学包代码到本地的src文件夹里 cd tutorial_ws/src git clone https://github.com/DroidAITech/ROS-Academy-for-Beginners.git 教学代码包还需要一些依赖文件，所以接下来就安装依赖文件 cd tutorial_ws rosdep install --from-paths src --ignore-src --rosdistro=kinetic -y 注：以上命令很重要，缺少依赖将导致教学包无法正常编译和运行 在开始编译教学代码之前，还需要确保安装的gazebo版本在7.0及7.0以上 使用指令查看一下 gazebo -v 如果你的gazebo版本低于7.0，则需要升级(命令来自于gazebo官网) sudo sh -c 'echo \"deb http://packages.osrfoundation.org/gazebo/ubuntu-stable `lsb_release -cs` main\" > /etc/apt/sources.list.d/gazebo-stable.list' wget http://packages.osrfoundation.org/gazebo.key -O - | sudo apt-key add - sudo apt-get update sudo apt-get install gazebo7 注：最后一行命令最好还是下载 gazebo7，更高版本可能会有其他问题 准备工作已经完成了，现在可以编译教学代码了 cd ~/tutorial_ws catkin_make source ~/tutorial_ws/devel/setup.bash 注：每一次使用catkin_make编译完成后，必须使用 source 命令刷新一下工作空间的环境，否则可能找不到工作空间。 许多时候我们为了打开终端就能够运行工作空间中编译好的ROS程序，我们习惯把source ~/tutorial_ws/devel/setup.bash命令追加到~/.bashrc文件中(tutorial_ws替换为你自己的工作空间名称)。这样每次打开终端，系统就会自动刷新工作空间环境了。你可以通过echo \"source ~/tutorial_ws/devel/setup.bash\" >> ~/.bashrc 命令来添加。 编译成功之后，就可以运行本教学配套的仿真程序了 输入命令：roslaunch robot_sim_demo robot_spawn.launch 你会看到仿真画面启动，仿真界面中包括了软件博物馆和Xbot机器人模型。注：第一次启动gazebo仿真软件，会比较慢，需要耐心等待一下。 另外打开一个终端，输入命令：rosrun robot_sim_demo robot_keyboard_teleop.py 将会打开键盘控制程序，可以控制机器人移动。 聚焦键盘控制终端窗口，按下I，J,L等按键，这样就通过键盘控制机器人移动了。 当完成了上面7个步骤之后，不知不觉中，我们就已经完成了ROS中最常见的源码下载->安装依赖->编译->运行的流程了。在ROS社区有许许多多这样的软件代码包，基本都按照这样的流程来运行。相信你一定可以举一反三。 © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-08 08:58:49 "},"Chapter2/二进制vs源码安装.html":{"url":"Chapter2/二进制vs源码安装.html","title":"第二篇 二进制vs源码安装","keywords":"","body":"二进制安装 vs 源代码安装 1. 二进制包与源代码包 我们通过apt方式安装了ROS系统以及相关的软件包，我们也通过下载源码的方式编译安装了一个ROS教学代码包。这是两种常见的软件包安装方式，通常我们的软件包(Package)就可以分为二进制和源代码。 二进制包里面包括了已经编译完成，可以直接运行的程序。通过 sudo apt-get install 来进行下载和解包（安装），执行完该指令后就可以马上使用了。因此这种方式简单快捷，适合比较固定、无需改动的程序。 而源代码包里是程序的原始代码，下载到你的计算机上必须经过编译，生成可执行的二进制文件之后，方可运行。一些个人开发的程序、第三方修改或者你希望修改的程序都应当通过源代码包的来编译安装。 区别 二进制包 源代码包 下载方式 apt-get install/直接下载deb git clone/直接下载源代码 ROS包存放位置 /opt/ros/kinetic/ 通常~/tutorial_ws/src 编译方式 无需编译 通过make/cmake/caktin_make 来源 官方apt软件源 开源项目、第三方开发者 扩展性 无法修改 通过源代码修改 可读性 无法查看源代码 方便阅读源代码 优点 下载简单，安装方便 源码可修改，便于定制功能 缺点 无法修改 编译工具、软件包依赖、版本和参数 应用场景 基础软件 需要查看、开发和修改的程序 我们用apt-get安装了ROS及其组件，因此我们不需要编译就可以运行turtlesim程序。对于这些程序，除非我们做操作系统的设计开发才会去下载源码，否则直接用官方提供的ROS软件包；而ROS-Academy-for-Beginners以源码呈现，你可以看到每个demo下面的C++源代码。对于这些源文件我们必须caktin_make编译，然后才能运行。 2. ROS二进制包的安装 在ROS中，我们可能经常会遇到缺少相关的ROS依赖的问题。有些时候你编译或者运行一些ROS程序，系统会提示找不到XXX功能包，如图所示。遇到这样的问题，请先注意阅读错误原因，看看是否有解决方法，也可以Google一下。如果是缺少ROS的依赖，通常可以用以下命令来安装： sudo apt-get install ros-kinetic-PACAKGE 将PACKAGE替换为系统提示缺少的软件包，例如 sudo apt-get install ros-kinetic-slam-gmapping #GMapping-SLAM算法包 sudo apt-get install ros-kinetic-turtlebot-description #Turtlebot机器人模型包 注：所有APT官方中的ROS功能包都是按照 ros- 的形式来命名的。 © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-07 17:59:02 "},"Chapter2/安装RoboWareStudio.html":{"url":"Chapter2/安装RoboWareStudio.html","title":"第三篇 安装RoboWare Studio","keywords":"","body":"安装 RoboWare Studio 通常ROS的程序都是用C++和Python开发的，为了提高开发的效率，我们建议用IDE来写代码。目前在Ubuntu上已经有许多IDE支持ROS开发，比如Eclipse、Qt Creator。不过这些IDE配置起来会比较麻烦，我们推荐一款适配ROS的IDE——RoboWare Studio来开发ROS。 RoboWare Studio现在官网已经不存在了，在2018年就不再维护更新了。这个软件是开源的，我们还是可以继续使用的。 我保存了RoboWare Studio的最后一个更新版本和中英文软件使用手册。可以访问我的github仓库地址，进行下载使用。 micro-coder/RoboWare_Studio_1.2.0 © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-07 17:59:02 "},"Chapter2/catkin编译系统.html":{"url":"Chapter2/catkin编译系统.html","title":"第四篇 catkin编译系统","keywords":"","body":"catkin编译系统 介绍了ROS的工程结构，也就是ROS的文件系统结构。要学会建立一个ROS工程，首先要认识一个ROS工程，了解它的组织架构，从根本上熟悉ROS项目的组织形式，了解各个文件的功能和作用，才能正确的进行开发和编程。 1. 概念 对于源代码包，我们只有编译完成之后，才能在系统上运行。而Linux下的编译器有gcc、g++，随着源文件的增加，直接用gcc/g++命令的方式显得效率低下，人们开始用Makefile来进行编译。然而随着工程体量的增大，Makefile也不能满足需求，于是便出现了Cmake工具。CMake是对make工具的生成器，是更高层的工具，它简化了编译构建过程，能够管理大型项目，具有良好的可扩展性。对于ROS这样大体量的平台来说，采用的就是CMake，并且ROS对CMake进行了扩展，于是便有了Catkin编译系统。 **早期的ROS编译系统是rosbuild**，但随着ROS的不断发展，rosbuild逐渐暴露出许多缺点，不能很好满足系统需要。**在Groovy版本面世后，Catkin作为rosbuild的替代品被正式投入使用。**Catkin操作更加简化且工作效率更高，可移植性更好，而且支持交叉编译和更加合理的功能包分配。目前的ROS同时支持着rosbuild和Catkin两种编译系统，但ROS的核心软件包也已经全部转换为Catkin。**rosbuild已经被逐步淘汰，所以建议初学者直接上手Catkin。** 2. catkin特点 Catkin是基于CMake的编译构建系统，具有以下特点： Catkin沿用了包管理的传统像 find_package()基础结构,pkg-config 扩展了CMake，例如 软件包编译后无需安装就可使用 自动生成find_package()代码，pkg-config文件 解决了多个软件包构建顺序问题 一个Catkin的软件包（package）必须要包括两个文件： package.xml : 包括了package的描述信息 name, description, version, maintainer(s), license opt. authors, url's, dependencies, plugins, etc... CMakeLists.txt: 构建package所需的CMake文件 调用Catkin的函数/宏 解析package.xml 找到其他依赖的catkin软件包 将本软件包添加到环境变量 3. catkin工作原理 catkin编译的工作流程如下： 首先在工作空间catkin_ws/src/下递归的查找其中每一个ROS的package。 package中会有package.xml和CMakeLists.txt文件，Catkin(CMake)编译系统依据CMakeLists.txt文件,从而生成makefiles(放在catkin_ws/build/)。 然后make刚刚生成的makefiles等文件，编译链接生成可执行文件(放在catkin_ws/devel)。 也就是说，Catkin就是将cmake与make指令做了一个封装从而完成整个编译过程的工具。catkin有比较突出的优点，主要是： 操作更加简单 一次配置，多次使用 跨依赖项目编译 4. catkin编译方法 要用catkin编译一个工程或软件包，只需要用catkin_make指令。一般当我们写完代码，执行一次catkin_make进行编译,就会自动完成编译和链接过程，构建生成目标文件。编译的一般性流程如下。在第一篇 学习资料源码下载我们编译ROS-Academy-for-Beginners教学包就是这样的步骤。cd ~/catkin_ws #进入到工作空间,catkin_make必须在工作空间的顶层目录下执行 catkin_make #开始编译 source ~/catkin_ws/devel/setup.bash #刷新坏境 注：这里的catkin_ws替换为tutorial_ws。前面已经说明过了，tutorial_ws或者catkin_ws只是文件夹名称，名称可以随意注: 使用catkin编译之前，必须回到工作空间的顶层目录，catkin_make在其他路径下编译不会成功。编译完成后，如果有新的目标文件产生，那么一般紧跟着要用source刷新一下环境，使得系统能够找到刚才编译生成的ROS可执行文件。这个细节比较容易遗漏，致使后面出现可执行文件无法打开等错误 catkin_make命令也有一些可选参数，例如：catkin_make [args]-h, --help 帮助信息 -C DIRECTORY, --directory DIRECTORY 工作空间的路径 (默认为 '.') --source SOURCE src的路径 (默认为'workspace_base/src') --build BUILD build的路径 (默认为'workspace_base/build') --use-ninja 用ninja取代make --use-nmake 用nmake取'make --force-cmake 强制cmake，即使已经cmake过 --no-color 禁止彩色输出(只对catkin_make和CMake生效) --pkg PKG [PKG ...] 只对某个PKG进行make --only-pkg-with-deps ONLY_PKG_WITH_DEPS [ONLY_PKG_WITH_DEPS ...] 将指定的package列入白名单 CATKIN_WHITELIST_PACKAGES， 之编译白名单里的package。该环境变量存在于 CMakeCache.txt。 --cmake-args [CMAKE_ARGS [CMAKE_ARGS ...]] 传给CMake的参数 --make-args [MAKE_ARGS [MAKE_ARGS ...]] 传给Make的参数 --override-build-tool-check 用来覆盖由于不同编译工具产生的错误 © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-09 19:04:40 "},"Chapter2/catkin工作空间.html":{"url":"Chapter2/catkin工作空间.html","title":"第五篇 catkin工作空间","keywords":"","body":"Catkin工作空间 Catkin工作空间是创建、修改、编译catkin软件包的文件夹。catkin的工作空间，直观的形容就是一个仓库，里面装载着ROS的各种项目工程，便于系统组织管理调用。在可视化图形界面里是一个文件夹。我们自己写的ROS代码通常就放在工作空间中。本篇就来介绍catkin工作空间的结构。 一、创建初始工作空间 介绍完catkin编译系统，我们来建立一个catkin的初始工作空间。首先我们要在计算机上创建一个初始的catkin_ws/src，这也是catkin工作空间结构的最高层级。输入下列指令，完成初始创建。 mkdir -p ~/catkin_ws/src　　 cd ~/catkin_ws/ catkin_make #初始化工作空间 第一行代码直接创建了文件夹catkin_ws文件夹和src子文件夹，这也是我们放ROS软件包的地方。第二行代码进入工作空间catkin_ws，然后再是catkin_make。 注： catkin_make命令必须在工作空间这个路径上执行 原先的初始化命令catkin_init_workspace仍然保留 二、工作空间结构 catkin的结构十分清晰，具体的catkin工作空间结构图如下。初看起来catkin工作空间看起来极其复杂，其实不然，catkin工作空间的结构其实非常清晰。 为了更形象的显示目录文件结构，这里我们需要先下载安装一个tree工具： sudo apt install tree 然后在工作空间下用tree命令，显示文件结构。 cd ~/catkin_ws tree 结果类似于： ─ build │ ├── catkin │ │ └── catkin_generated │ │ └── version │ │ └── package.cmake │ ├── ...... │ ├── catkin_make.cache │ ├── CMakeCache.txt │ ├── CMakeFiles │ │ ├── ...... ├── devel │ ├── env.sh │ ├── lib │ ├── setup.bash │ ├── setup.sh │ ├── _setup_util.py │ └── setup.zsh └── src └── CMakeLists.txt -> /opt/ros/kinetic/share/catkin/cmake/toplevel.cmake 通过tree命令可以看到catkin工作空间的结构,它包括了src、build、devel三个文件路径，在有些编译选项下也可能包括其他。但这三个文件夹是catkin编译系统默认的。它们的具体作用如下： src/: ROS的catkin软件包(源代码包)；自己手动创建; build/: catkin(CMake)的缓存信息和中间文件；自动生成; devel/: 用于存放生成的目标文件(包括头文件，动态链接库，静态链接库，可执行文件等)、环境变量(setup.bash等)；自动生成; 在编译过程中，它们的工作流程如图： 后两个路径由catkin系统自动生成、管理，我们日常的开发一般不会去涉及。而主要用到的是src文件夹，我们写的ROS程序、网上下载的ROS源代码包都存放在这里。在编译时，catkin编译系统会递归的查找和编译src/下的每一个源代码包。因此你也可以把几个源代码包放到同一个文件夹下，如下图所示： 小结 catkin工作空间基本就是以上的结构，package是catkin工作空间的基本单元，我们在ROS开发时，写好代码，然后catkin_make，系统就会完成所有编译构建的工作。至于更详细的package内容，我们将在下一篇继续介绍。 © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-08 11:25:31 "},"Chapter2/package.html":{"url":"Chapter2/package.html","title":"第六篇 package包","keywords":"","body":"package包 在前面第二篇分别介绍了二进制包和源代码包。ROS中对package的定义更加具体，它不仅是Linux上的软件包，更是catkin编译的基本单元，我们调用catkin_make编译的对象就是一个个ROS的package，也就是说任何ROS程序只有组织成package才能编译。所以package也是ROS源代码存放的地方，任何ROS的代码无论是C++还是Python都要放到package中，这样才能正常的编译和运行。一个package可以编译出来多个目标文件（ROS可执行程序、动态静态库、头文件等等）。 一、package结构 一个package下常见的文件、路径有： ├── CMakeLists.txt #package的编译规则(必须) ├── package.xml #package的描述信息(必须) ├── src/ #源代码文件 ├── include/ #C++头文件 ├── scripts/ #可执行脚本 ├── msg/ #自定义消息 ├── srv/ #自定义服务 ├── models/ #3D模型文件 ├── urdf/ #urdf文件 ├── launch/ #launch文件 其中定义package的是CMakeLists.txt和package.xml，这两个文件是package中必不可少的。catkin编译系统在编译前，首先就要解析这两个文件。这两个文件就定义了一个package。 CMakeLists.txt: 定义package的包名、依赖、源文件、目标文件等编译规则，是package不可少的成分 package.xml: 描述package的包名、版本号、作者、依赖等信息，是package不可少的成分 src/: 存放ROS的源代码，包括C++的源码和(.cpp)以及Python的module(.py) include/: 存放C++源码对应的头文件 scripts/: 存放可执行脚本，例如shell脚本(.sh)、Python脚本(.py) msg/: 存放自定义格式的消息(.msg) srv/: 存放自定义格式的服务(.srv) models/: 存放机器人或仿真场景的3D模型(.sda, .stl, .dae等) urdf/: 存放机器人的模型描述(.urdf或.xacro) launch/: 存放launch文件(.launch或 .xml) 通常ROS文件组织都是按照以上的形式，这是约定俗成的命名习惯，建议遵守。以上路径中，只有CMakeLists.txt和package.xml是必须的，其余路径根据软件包是否需要来决定。 二、package的创建 创建一个package需要在catkin_ws/src下,用到 catkin_create_pkg命令，用法是： catkin_create_pkg package depends 其中package是包名，depends是依赖的包名，可以依赖多个软件包。例如，新建一个package叫做test_pkg,依赖roscpp、rospy、std_msgs(这些都是常用依赖)。 catkin_create_pkg test_pkg roscpp rospy std_msgs 这样就会在当前路径下新建test_pkg软件包，包括： ├── CMakeLists.txt ├── include │ └── test_pkg ├── package.xml └── src 如图所示： catkin_create_pkg帮你完成了软件包的初始化，填充好了CMakeLists.txt和package.xml，并且将依赖项填进了这两个文件中。 三、package相关命令 1. rospack rospack是对package管理的工具，命令的用法如下： rostopic命令 作用 rospack help 显示rospack的用法 rospack list 列出本机所有package rospack depends [package] 显示package的依赖包 rospack find [package] 定位某个package rospack profile 刷新所有package的位置记录 注：以上命令如果package缺省，则默认为当前目录(如果当前目录包含package.xml) 2. roscd roscd 命令类似与Linux系统的 cd ，改进之处在于roscd可以直接cd到ROS的软件包。 rostopic命令 作用 roscd [pacakge] cd到ROS package所在路径 3. rosls rosls也可以视为Linux指令ls的改进版，可以直接lsROS软件包的内容。 rosls命令 作用 rosls [pacakge] 列出pacakge下的文件 4. rosdep rosdep是用于管理ROS package依赖项的命令行工具，用法如下： rosdep命令 作用 rosdep check [pacakge] 检查package的依赖是否满足 rosdep install [pacakge] 安装pacakge的依赖 rosdep db 生成和显示依赖数据库 rosdep init 初始化/etc/ros/rosdep中的源 rosdep keys 检查package的依赖是否满足 rosdep update 更新本地的rosdep数据库 一个较常使用的命令是rosdep install --from-paths src --ignore-src --rosdistro=kinetic -y,用于安装工作空间中src路径下所有package的依赖项（由pacakge.xml文件指定）。这个指令在第一篇 学习资料源码下载使用过。 © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-08 15:56:06 "},"Chapter2/CMakeLists.txt.html":{"url":"Chapter2/CMakeLists.txt.html","title":"第七篇 CMakeLists.txt","keywords":"","body":"CMakeLists.txt CMakeLists.txt原本是Cmake编译系统的规则文件，而Catkin编译系统基本沿用了CMake的编译风格，只是针对ROS工程添加了一些宏定义。所以在写法上，catkin的CMakeLists.txt与CMake的基本一致。 这个文件直接规定了这个package要依赖哪些package，要编译生成哪些目标，如何编译等等流程。所以CMakeLists.txt非常重要，它指定了由源码到目标文件的规则，catkin编译系统在工作时首先会找到每个package下的CMakeLists.txt，然后按照规则来编译构建。 一、CMakeLists.txt写法 CMakeLists.txt的基本语法都还是按照CMake，而Catkin在其中加入了少量的宏，总体的结构如下： cmake_minimum_required() #CMake的版本号 project() #项目名称 find_package() #找到编译需要的其他CMake/Catkin package catkin_python_setup() #catkin新加宏，打开catkin的Python Module的支持 add_message_files() #catkin新加宏，添加自定义Message/Service/Action文件 add_service_files() add_action_files() generate_message() #catkin新加宏，生成不同语言版本的msg/srv/action接口 catkin_package() #catkin新加宏，生成当前package的cmake配置，供依赖本包的其他软件包调用 add_library() #生成库 add_executable() #生成可执行二进制文件 add_dependencies() #定义目标文件依赖于其他目标文件，确保其他目标已被构建 target_link_libraries() #链接 catkin_add_gtest() #catkin新加宏，生成测试 install() #安装至本机 如果你从未接触过CMake的语法，请阅读《CMake实践》 。掌握CMake语法对于理解ROS工程很有帮助。 CMakeLists例子 为了详细的解释CMakeLists.txt的写法，我们以turtlesim小海龟这个pacakge为例，读者可roscd到tuetlesim包下查看，在turtlesim/CMakeLists.txt的写法如下: cmake_minimum_required(VERSION 2.8.3) #CMake至少为2.8.3版 project(turtlesim) #项目(package)名称为turtlesim，在后续文件中可使用变量${PROJECT_NAME}来引用项目名称turltesim find_package(catkin REQUIRED COMPONENTS geometry_msgs message_generation rosconsole roscpp roscpp_serialization roslib rostime std_msgs std_srvs) #cmake宏，指定依赖的其他pacakge，实际是生成了一些环境变量，如_FOUND, _INCLUDE_DIRS, _LIBRARYIS #此处catkin是必备依赖 其余的geometry_msgs...为组件 find_package(Qt5Widgets REQUIRED) find_package(Boost REQUIRED COMPONENTS thread) include_directories(include ${catkin_INCLUDE_DIRS} ${Boost_INCLUDE_DIRS}) #指定C++的头文件路径 link_directories(${catkin_LIBRARY_DIRS}) #指定链接库的路径 add_message_files(DIRECTORY msg FILES Color.msg Pose.msg) #自定义msg文件 add_service_files(DIRECTORY srv FILES Kill.srv SetPen.srv Spawn.srv TeleportAbsolute.srv TeleportRelative.srv) #自定义srv文件 generate_messages(DEPENDENCIES geometry_msgs std_msgs std_srvs) #在add_message_files、add_service_files宏之后必须加上这句话，用于生成srv msg头文件/module，生成的文件位于devel/include中 catkin_package(CATKIN_DEPENDS geometry_msgs message_runtime std_msgs std_srvs) # catkin宏命令，用于配置ROS的package配置文件和CMake文件 # 这个命令必须在add_library()或者add_executable()之前调用，该函数有5个可选参数： # (1) INCLUDE_DIRS - 导出包的include路径 # (2) LIBRARIES - 导出项目中的库 # (3) CATKIN_DEPENDS - 该项目依赖的其他catkin项目 # (4) DEPENDS - 该项目所依赖的非catkin CMake项目。 # (5) CFG_EXTRAS - 其他配置选项 set(turtlesim_node_SRCS src/turtlesim.cpp src/turtle.cpp src/turtle_frame.cpp ) set(turtlesim_node_HDRS include/turtlesim/turtle_frame.h ) #指定turtlesim_node_SRCS、turtlesim_node_HDRS变量 qt5_wrap_cpp(turtlesim_node_MOCS ${turtlesim_node_HDRS}) add_executable(turtlesim_node ${turtlesim_node_SRCS} ${turtlesim_node_MOCS}) # 指定可执行文件目标turtlesim_node target_link_libraries(turtlesim_node Qt5::Widgets ${catkin_LIBRARIES} ${Boost_LIBRARIES}) # 指定链接可执行文件 add_dependencies(turtlesim_node turtlesim_gencpp) add_executable(turtle_teleop_key tutorials/teleop_turtle_key.cpp) target_link_libraries(turtle_teleop_key ${catkin_LIBRARIES}) add_dependencies(turtle_teleop_key turtlesim_gencpp) add_executable(draw_square tutorials/draw_square.cpp) target_link_libraries(draw_square ${catkin_LIBRARIES} ${Boost_LIBRARIES}) add_dependencies(draw_square turtlesim_gencpp) add_executable(mimic tutorials/mimic.cpp) target_link_libraries(mimic ${catkin_LIBRARIES}) add_dependencies(mimic turtlesim_gencpp) # 同样指定可执行目标、链接、依赖 install(TARGETS turtlesim_node turtle_teleop_key draw_square mimic RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}) # 安装目标文件到本地系统 install(DIRECTORY images DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION} FILES_MATCHING PATTERN \"*.png\" PATTERN \"*.svg\") © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-08 16:07:19 "},"Chapter2/package_xml.html":{"url":"Chapter2/package_xml.html","title":"第八篇 package.xml","keywords":"","body":"package.xml package.xml也是一个catkin的package必备文件，它是这个软件包的描述文件，在较早的ROS版本(rosbuild编译系统)中，这个文件叫做manifest.xml，用于描述pacakge的基本信息。如果你在网上看到一些ROS项目里包含着manifest.xml，那么它多半是hydro版本之前的项目。 package.xml作用 pacakge.xml包含package的名称、版本号、内容描述、维护人员、软件许可、编译构建工具、编译依赖、运行依赖等信息。 实际上rospack find、rosdep等命令之所以能快速定位和分析出package的依赖项信息，就是直接读取了每一个pacakge中的package.xml文件。它为用户提供了快速了解一个pacakge的渠道。 package.xml写法 pacakge.xml遵循xml标签文本的写法，由于版本更迭原因，现在有两种格式并存（format1与format2），不过区别不大。老版本（format1）的pacakge.xml通常包含以下标签: 根标记文件 包名 版本号 内容描述 维护者 软件许可证 编译构建工具，通常为catkin 编译依赖项，与Catkin中的 运行依赖项 说明：其中1-6为必备标签，1是根标签，嵌套了其余的所有标签，2-6为包的各种属性，7-9为编译相关信息。 在新版本（format2）中，包含的标签为： 根标记文件 包名 版本号 内容描述 维护者 软件许可证 编译构建工具，通常为catkin 指定依赖项为编译、导出、运行需要的依赖，最常用 编译依赖项 导出依赖项 运行依赖项 测试用例依赖项 文档依赖项 目前Indigo、Kinetic、Lunar等版本的ROS都同时支持两种版本的package.xml，所以无论选哪种格式都可以。 package.xml例子 为了说明pacakge.xml写法，还是以turtlesim软件包为例，其pacakge.xml文件内容如下，我们添加了相关的注释： turtlesim 0.8.1 turtlesim is a tool made for teaching ROS and ROS packages. Dirk Thomas BSD http://www.ros.org/wiki/turtlesim https://github.com/ros/ros_tutorials/issues https://github.com/ros/ros_tutorials Josh Faust catkin geometry_msgs qtbase5-dev message_generation qt5-qmake rosconsole roscpp roscpp_serialization roslib rostime std_msgs std_srvs geometry_msgs libqt5-core libqt5-gui message_runtime rosconsole roscpp roscpp_serialization roslib rostime std_msgs std_srvs 以上内容是老版本（format1）的写法，如果要写成新版本（format2）则可以改为： turtlesim 0.8.1 turtlesim is a tool made for teaching ROS and ROS packages. Dirk Thomas BSD http://www.ros.org/wiki/turtlesim https://github.com/ros/ros_tutorials/issues https://github.com/ros/ros_tutorials Josh Faust catkin geometry_msgs rosconsole roscpp roscpp_serialization roslib rostime std_msgs std_srvs qtbase5-dev message_generation qt5-qmake libqt5-core libqt5-gui message_runtime © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-09 17:51:14 "},"Chapter2/Metapackage.html":{"url":"Chapter2/Metapackage.html","title":"第九篇 Metapackage","keywords":"","body":"Metapackage 在一些ROS的教学资料和博客里，你可能还会看到一个Stack（功能包集）的概念，它指的是将多个功能接近、甚至相互依赖的软件包的放到一个集合中去。但Stack这个概念在Hydro之后就取消了，取而代之的就是Metapackage。尽管换了个马甲，但它的作用没变，都是把一些相近的功能模块、软件包放到一起。 ROS里常见的Metapacakge有： Metapacakge名称 描述 链接 navigation 导航相关的功能包集 https://github.com/ros-planning/navigation moveit 运动规划相关的（主要是机械臂）功能包集 https://github.com/ros-planning/moveit image_pipeline 图像获取、处理相关的功能包集 https://github.com/ros-perception/image_common vision_opencv ROS与OpenCV交互的功能包集 https://github.com/ros-perception/vision_opencv turtlebot Turtlebot机器人相关的功能包集 https://github.com/turtlebot/turtlebot pr2_robot pr2机器人驱动功能包集 https://github.com/PR2/pr2_robot ... ... ... 以上列举了一些常见的功能包集，例如navigation、turtlebot，他们都是用于某一方面的功能，以navigation metapackage（官方介绍里仍然沿用stack的叫法）为例，它包括了以下软件包： 包名 功能 navigation Metapacakge，依赖以下所有pacakge amcl 定位 fake_localization 定位 map_server 提供地图 move_base 路径规划节点 nav_core 路径规划的接口类 base_local_planner 局部规划 dwa_local_planner 局部规划 ... ... 这里只看一个软件包navigation。这个navigation就是一个简单的pacakge，里面只有几个文件，但由于它依赖了其他所有的软件包。Catkin编译系统会明白，这些软件包都属于navigation metapacakge。 这个道理并不难理解，比如我们在安装ROS时，用到了sudo apt-get install ros-kinetic-desktop-full命令，由于它依赖了ROS所有的核心组件，我们在安装时也就能够安装整个ROS。 Metapackage写法 我们以ROS-Academy-for-beginners为例介绍meteapckage的写法。在教学包内，有一个ros-academy-for-beginners软件包，该包即为一个metapacakge，其中有且仅有两个文件：CMakeLists.txt和pacakge.xml。(这两个文件在github下载页中) CMakeLists.txt写法如下： cmake_minimum_required(VERSION 2.8.3) project(ros_academy_for_beginners) find_package(catkin REQUIRED) catkin_metapackage() package.xml写法如下: ros_academy_for_beginners 18.2.10 -------------------------------------------------------------------------- A ROS tutorial for beginner level learners. This metapacakge includes some demos of topic, service, parameter server, tf, urdf, navigation, SLAM... It tries to explain the basic concepts and usages of ROS. -------------------------------------------------------------------------- Chai Changkun Chai Changkun BSD http://rosacademy.cn catkin navigation_sim_demo param_demo robot_sim_demo service_demo slam_sim_demo tf_demo topic_demo metapacakge中的以上两个文件和普通pacakge不同点是： CMakeLists.txt:加入了catkin_metapackage()宏，指定本软件包为一个metapacakge。 package.xml:标签将所有软件包列为依赖项，标签中添加标签声明。 metapacakge在我们实际开发一个大工程时可能有用 © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-09 18:08:49 "},"Chapter2/其他常见文件类型.html":{"url":"Chapter2/其他常见文件类型.html","title":"第十篇 其他常见文件类型","keywords":"","body":"其他常见文件类型 在ROS的pacakge中，还有其他许多常见的文件类型，这里做个总结。 一、launch文件 launch文件一般以.launch或.xml结尾，它对ROS需要运行程序进行了打包，通过一句命令来启动。一般launch文件中会指定要启动哪些package下的哪些可执行程序，指定以什么参数启动，以及一些管理控制的命令。launch文件通常放在软件包的launch/路径中中。 二、msg/srv/action文件 ROS程序中有可能有一些自定义的消息/服务/动作文件，为程序的发者所设计的数据结构，这类的文件以.msg,.srv,.action结尾，通常放在package的msg/,srv/,action/路径下。 三、urdf/xacro文件 urdf/xacro文件是机器人模型的描述文件，以.urdf或.xacro结尾。它定义了机器人的连杆和关节的信息，以及它们之间的位置、角度等信息，通过urdf文件可以将机器人的物理连接信息表示出来。并在可视化调试和仿真中显示。 urdf文件的写法见第七章。 四、yaml文件 yaml文件一般存储了ROS需要加载的参数信息，一些属性的配置。通常在launch文件或程序中读取.yaml文件，把参数加载到参数服务器上。通常我们会把yaml文件存放在param/路径下 五、dae/stl文件 dae或stl文件是3D模型文件，机器人的urdf或仿真环境通常会引用这类文件，它们描述了机器人的三维模型。相比urdf文件简单定义的性状，dae/stl文件可以定义复杂的模型，可以直接从solidworks或其他建模软件导出机器人装配模型，从而显示出更加精确的外形。 六、rviz文件 rviz文件本质上是固定格式的文本文件，其中存储了RViz窗口的配置（显示哪些控件、视角、参数）。通常rviz文件不需要我们去手动修改，而是直接在RViz工具里保存，下次运行时直接读取。 © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-09 18:18:01 "},"Chapter2/小结.html":{"url":"Chapter2/小结.html","title":"小结篇","keywords":"","body":"Chpaer 2 小结 © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-07 17:59:02 "},"Chapter3/Introduction.html":{"url":"Chapter3/Introduction.html","title":"第三章 ROS通信架构体系","keywords":"","body":"Chapter 3 Introduction 本章学习ROS的通信架构，即ROS的各种通信方式。ROS的通信架构是ROS的灵魂，也是整个ROS正常运行的关键所在。ROS通信架构包括对各种数据的处理，进程的运行，消息的传递等等。本章介绍通信架构的基础通信方式和相关概念。首先介绍最小的进程单元节点 Node,和节点管理器Node master。了解ROS中的进程都是由很多的Node组成，并且由Node master来管理这些节点。 第二篇介绍ROS的“发动机”——launch文件，学习它的格式和内容，更深入的理解ROS在启动运行时它的工作都是由什么进程支配的，从而理解启动运行的原理。 在后面的几篇中介绍ROS通信方式。ROS中的通信方式有四种，主题、服务、参数服务器、动作库。每个通信方式都有自己的特点，自己不同的适用方面。 © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-10 15:25:58 "},"Chapter3/node&master.html":{"url":"Chapter3/node&master.html","title":"第一篇 node&master","keywords":"","body":"node & master 一、 node 在ROS的世界里，最小的进程单元就是节点（node）。一个软件包里可以有多个可执行文件，可执行文件在运行之后就成了一个进程(process)，这个进程在ROS中就叫做节点。 从程序角度来说，node就是一个可执行文件（通常为C++编译生成的可执行文件、Python脚本）被执行，加载到了内存之中；从功能角度来说，通常一个node负责者机器人的某一个单独的功能。由于机器人的功能模块非常复杂，我们往往不会把所有功能都集中到一个node上，而会采用分布式的方式，把鸡蛋放到不同的篮子里。例如有一个node来控制底盘轮子的运动，有一个node驱动摄像头获取图像，有一个node驱动激光雷达，有一个node根据传感器信息进行路径规划……这样做可以降低程序发生崩溃的可能性，试想一下如果把所有功能都写到一个程序中，模块间的通信、异常处理将会很麻烦。 我们在第二篇 ROS配置打开了小海龟的运动程序和键盘控制程序，在1.5节同样启动了键盘运动程序，这每一个程序便是一个node。ROS系统中不同功能模块之间的通信，也就是节点间的通信。我们可以把键盘控制替换为其他控制方式，而小海龟运动程序、机器人仿真程序则不用变化。这样就是一种模块化分工的思想。 二、master 由于机器人的元器件很多，功能庞大，因此实际运行时往往会运行众多的node，负责感知世界、控制运动、决策和计算等功能。那么如何合理的进行调配、管理这些node呢？这就要利用ROS提供给我们的节点管理器master, master在整个网络通信架构里相当于管理中心，管理着各个node。node首先在master处进行注册，之后master会将该node纳入整个ROS程序中。node之间的通信也是先由master进行“牵线”，才能两两的进行点对点通信。当ROS程序启动时，第一步首先启动master，由节点管理器处理依次启动node。 三、启动master和node 当我们要启动ROS时，首先输入命令: roscore 此时ROS master启动，同时启动的还有rosout和parameter server。其中rosout是负责日志输出的一个节点，其作用是告知用户当前系统的状态，包括输出系统的error、warning等等，并且将log记录于日志文件中。parameter server即是参数服务器，它并不是一个node，而是存储参数配置的一个服务器，后文我们会单独介绍。每一次我们运行ROS的节点前，都需要把master启动起来，这样才能够让节点node启动和注册。 masterq启动之后，节点管理器master就开始按照系统的安排协调进行启动具体的节点。节点就是一个进程，只不过在ROS中它被赋予了专用的名字里——node。在第二章我们介绍了ROS的文件系统，我们知道一个package中存放着可执行文件，可执行文件是静态的，当系统执行这些可执行文件，将这些文件加载到内存中，它就成为了动态的node。具体启动node的语句是： rosrun pkg_name node_name 通常我们运行ROS，就是按照这样的顺序启动。有时候节点太多，我们会选择用launch文件来启动。Master、Node之间以及Node之间的关系如下图所示： rosrun和rosnode命令 rosrun命令的详细用法如下： rosrun [--prefix cmd] [--debug] pkg_name node_name [ARGS] rosrun将会寻找package下的名为executable的可执行程序，将可选参数ARGS传入。 例如在gdb下运行ros程序： rosrun --prefix 'gdb -ex run --args' pkg_name node_name rosnode命令的详细作用列表如下： rosnode命令 作用 rosnode help rosnode使用帮助信息 rosnode list 列出当前运行的node信息 rosnode info node_name 显示出node的详细信息 rosnode kill node_name 结束某个node rosnode ping 测试连接节点 rosnode machine 列出在特定机器或列表机器上运行的节点 rosnode cleanup 清除不可到达节点的注册信息 以上命令中常用的为前三个，在开发调试时经常会需要查看当前node以及node信息，所以请记住这些常用命令。如果你想不起来，也可以通过rosnode help来查看rosnode命令的用法。 © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-09 19:22:42 "},"Chapter3/launch.html":{"url":"Chapter3/launch.html","title":"第二篇 launch文件","keywords":"","body":"launch文件 机器人是一个系统工程，通常一个机器人运行操作时要开启很多个node，对于一个复杂的机器人的启动操作应该怎么做呢？当然，我们并不需要每个节点依次进行rosrun，ROS为我们提供了一个命令能一次性启动master和多个node。该命令是： roslaunch pkg_name file_name.launch roslaunch命令首先会自动检测系统的roscore有没有运行，也即是确认节点管理器是否处于运行状态，如果master没有启动，那么roslaunch就会首先启动master，然后再按照launch文件的规则执行。launch文件里已经配置好了启动规则。 所以roslaunch就像是一个启动工具，能够一次性把多个节点按照我们预先的配置启动起来，减少我们在终端中一条条输入指令的麻烦。 一、lanunch文件写法与与格式 launch文件同样也遵循着xml格式规范，是一种标签文本，它的格式包括以下标签： 参考链接:http://wiki.ros.org/roslaunch/XML 二、launch示例 launch文件的写法和格式看起来内容比较复杂，我们先来介绍一个最简单的例子如下： 这是官网给出的一个最小的例子。文本中的信息是，它启动了一个单独的节点talker,该节点是包rospy_tutorials软件包中的节点。 然而实际中的launch文件要复杂很多，我们以Ros-Academy-for-Beginners中的robot_sim_demo为例： 这个launch文件相比上一个简单的例子来说，内容稍微有些复杂，它的作用是：启动gazebo模拟器，导入参数内容，加入机器人模型。 © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-10 12:24:08 "},"Chapter3/topic.html":{"url":"Chapter3/topic.html","title":"第三篇 topic话题","keywords":"","body":"topic通信方式 ROS的通信方式是ROS最为核心的概念，ROS系统的精髓就在于它提供的通信架构。ROS的通信方式有以下四种： Topic 主题 Service 服务 Parameter Service 参数服务器 Actionlib 动作库 一、topic简介 ROS中的通信方式中，topic是常用的一种。对于实时性、周期性的消息，使用topic来传输是最佳的选择。topic是一种点对点的单向通信方式，这里的“点”指的是node，也就是说node之间可以通过topic方式来传递信息。topic要经历下面几步的初始化过程：首先，publisher节点和subscriber节点都要到节点管理器进行注册，然后publisher会发布topic，subscriber在master的指挥下会订阅该topic，从而建立起sub-pub之间的通信。注意整个过程是单向的。其结构示意图如下： Subscriber接收消息会进行处理，一般这个过程叫做回调(Callback)。所谓回调就是指提前定义好了一个处理函数（写在代码中），当有消息来就会触发这个处理函数，此函数会对消息进行处理。 上图就是ROS的topic通信方式的流程示意图。topic通信属于一种异步的通信方式。下面我们通过一个示例来了解下如何使用topic通信。 二、topic通信示例 参考下图，我们以摄像头画面的发布、处理、显示为例,讲讲topic通信的流程。在机器人上的摄像头拍摄程序是一个node（圆圈表示,我们记作node1），当node1注册、运行、启动之后，它作为一个Publisher就开始发布topic。比如它发布了一个topic（方框表示），叫做/camera_rgb，是rgb颜色信息，即采集到的彩色图像。同时，node2假如是图像处理程序,它作为一个subscriber订阅了/camera_rgb这个topic，经过节点管理器的介绍，它就能建立和摄像头节点（node1）的连接。 那么怎么样来理解“异步”这个概念呢？在node1每发布一次消息之后，就会继续执行下一个动作，至于消息发出去之后是什么状态、被怎样处理，它不需要了解；而对于node2图像处理程序，它只管接收和处理/camera_rgb上的消息，至于是谁发来的，它不会关心。所以node1、node2两者都是各司其责，不存在协同工作，我们称这样的通信方式是异步的。 ROS是一种分布式的架构，同一个topic可以有多个节点同时发布，也可以同时被多个节点接收。比如在这个场景中，用户可以再加入一个图像显示的节点，我们还想看看摄像头节点的实时画面，则可以用自己的笔记本连接到机器人上的节点管理器，然后在自己的电脑上启动图像显示节点。 这就体现了分布式系统通信的好处：扩展性好、软件复用率高。 总结： topic通信方式是异步的，发送时调用publish()方法，发送完成立即返回，不用等待反馈。 subscriber通过回调函数的方式来处理消息。 topic可以同时有多个subscribers，也可以同时有多个publishers。ROS中这样的例子有：/rosout、/tf等等。 三、topic操作命令 在实际应用中，我们应该熟悉topic的几种使用命令，下表详细的列出了各自的命令及其作用。 命令 作用 rostopic list 列出当前所有的topic rostopic info topic_name 显示某个topic的属性信息 rostopic echo topic_name 显示某个topic的内容 rostopic pub topic_name ... 向某个topic发布内容 rostopic bw topic_name 查看某个topic的带宽 rostopic hz topic_name 查看某个topic的频率 rostopic find topic_type 查找某个类型的topic rostopic type topic_name 查看某个topic的类型(msg) 如果你一时忘记了命令的写法，可以通过rostopic help或rostopic command -h查看具体用法。 四、topic测试示例 首先打开ROS-Academy-for-Beginners的模拟场景，输入roslaunch robot_sim_demo robot_spawn_launch 看到我们仿真的模拟环境。该launch文件启动了模拟场景、机器人。 如图所示： 查看当前模拟器中存在的topic，输入命令rostopic list 可以看到终端输出许多topic，它们可以视为模拟器与外界交互的接口。 如图所示： 查询topic ： /camera/rgb/image_raw 的相关信息：rostopic info /camera/rgb/image_raw 则会显示类型信息type，发布者和订阅者的信息。 如图所示： 上步我们在演示中可以得知，并没有订阅者订阅该主题，我们指定image_view来接收这个消息，运行命令rosrun image_view image_view image:=/camera/rgb/image_raw 我们可以看到message，即是上一步中的type，并弹出一个图像窗口 如图所示： 同理我们可以查询摄像头的深度信息depth图像。 在用键盘控制仿真机器人运动的时候，我们可以查看速度指令topic的内容rostopic echo /cmd_vel ，可以看到窗口显示的各种坐标参数在不断的变化。 通过这些实例的测试，帮助我们更快的掌握topic各种操作命令的使用，以及对topic通信的理解。 © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-10 12:23:51 "},"Chapter3/message.html":{"url":"Chapter3/message.html","title":"第四篇 msg消息格式","keywords":"","body":"message消息格式 topic有很严格的格式要求，比如上节的摄像头进程中的rgb图像topic，它就必然要遵循ROS中定义好的rgb图像格式。这种数据格式就是Message。Message按照定义解释就是topic内容的数据类型，也称之为topic的格式标准。这里和我们平常用到的Massage直观概念有所不同，这里的Message不单单指一条发布或者订阅的消息，也指定为topic的格式标准。 一、message结构与类型 基本的msg包括bool、int8、int16、int32、int64(以及uint)、float、float64、string、time、duration、header、可变长数组array[] 、固定长度数组array[C]。那么具体的一个msg是怎么组成的呢？我们用一个具体的msg来了解，例如上例中的msg：sensor_msg/image,文件的绝对路径是 /opt/ros/kinetic/share/sensor_msgs,它的结构如下： # This message contains an uncompressed image # (0, 0) is at top-left corner of image # Header header # Header timestamp should be acquisition time of image # Header frame_id should be optical frame of camera # origin of frame should be optical center of camera # +x should point to the right in the image # +y should point down in the image # +z should point into to plane of the image # If the frame_id here and the frame_id of the CameraInfo # message associated with the image conflict # the behavior is undefined uint32 height # image height, that is, number of rows uint32 width # image width, that is, number of columns # The legal values for encoding are in file src/image_encodings.cpp # If you want to standardize a new string format, join # ros-users@lists.sourceforge.net and send an email proposing a new encoding. string encoding # Encoding of pixels -- channel meaning, ordering, size # taken from the list of strings in include/sensor_msgs/image_encodings.h uint8 is_bigendian # is this data bigendian? uint32 step # Full row length in bytes uint8[] data # actual matrix data, size is (step * rows) 可以看到，这里还嵌套了Header结构体： # Standard metadata for higher-level stamped data types. # This is generally used to communicate timestamped data # in a particular coordinate frame. # # sequence ID: consecutively increasing ID uint32 seq #Two-integer timestamp that is expressed as: # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs') # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs') # time-handling sugar is provided by the client library time stamp #Frame this data is associated with # 0: no frame # 1: global frame string frame_id 观察上面msg的定义，是不是很类似C语言中的结构体呢？通过具体的定义图像的宽度，高度等等来规范图像的格式。所以这就解释了Message不仅仅是我们平时理解的一条一条的消息，而且更是ROS中topic的格式规范。或者可以理解msg是一个“类”，那么我们每次发布的内容可以理解为“对象”，这么对比来理解可能更加容易。 我们实际通常不会把Message概念分的那么清，通常说Message既指的是类，也是指它的对象。而msg文件则相当于类的定义了。 二、msg操作命令 rosmsg的命令相比topic就比较少了，只有两个如下： rosmsg命令 作用 rosmsg list 列出系统上所有的msg rosmsg show msg_name 显示某个msg的内容 三、常见msg消息格式 常见的message类型，包括std_msgs, sensor_msgs, nav_msgs, geometry_msgs等 Vector3.msg 文件位置:geometry_msgs/Vector3.msg float64 x float64 y float64 z Accel.msg 定义加速度项，包括线性加速度和角加速度文件位置:geometry_msgs/Accel.msg Vector3 linear Vector3 angular Header.msg 定义数据的参考时间和参考坐标文件位置:std_msgs/Header.msg uint32 seq #数据ID time stamp #数据时间戳 string frame_id #数据的参考坐标系 Echos.msg 定义超声传感器文件位置:自定义msg文件 Header header uint16 front_left uint16 front_center uint16 front_right uint16 rear_left uint16 rear_center uint16 rear_right Quaternion.msg 消息代表空间中旋转的四元数文件位置:geometry_msgs/Quaternion.msg float64 x float64 y float64 z float64 w Imu.msg 消息包含了从惯性原件中得到的数据，加速度为m/^2，角速度为rad/s如果所有的测量协方差已知，则需要全部填充进来如果只知道方差，则只填充协方差矩阵的对角数据即可文件位置：sensor_msgs/Imu.msg Header header Quaternion orientation float64[9] orientation_covariance Vector3 angular_velocity float64[9] angular_velocity_covariance Vector3 linear_acceleration float64[] linear_acceleration_covariance LaserScan.msg 平面内的激光测距扫描数据注意此消息类型仅仅适配激光测距设备,如果有其他类型的测距设备(如声呐)，需要另外创建不同类型的消息文件位置：sensor_msgs/LaserScan.msg Header header #时间戳为接收到第一束激光的时间 float32 angle_min #扫描开始时的角度(单位为rad) float32 angle_max #扫描结束时的角度(单位为rad) float32 angle_increment #两次测量之间的角度增量(单位为rad) float32 time_increment #两次测量之间的时间增量(单位为s) float32 scan_time #两次扫描之间的时间间隔(单位为s) float32 range_min #距离最小值(m) float32 range_max #距离最大值(m) float32[] ranges #测距数据(m,如果数据不在最小数据和最大数据之间，则抛弃) float32[] intensities #强度，具体单位由测量设备确定，如果仪器没有强度测量，则数组为空即可 Point.msg 空间中的点的位置文件位置:geometry_msgs/Point.msg float64 x float64 y float64 z Pose.msg 消息定义自由空间中的位姿信息，包括位置和指向信息文件位置:geometry_msgs/Pose.msg Point position Quaternion orientation PoseStamped.msg 定义有时空基准的位姿文件位置：geometry_msgs/PoseStamped.msg Header header Pose pose PoseWithCovariance.msg 表示空间中含有不确定性的位姿信息文件位置：geometry_msgs/PoseWithCovariance.msg Pose pose float64[36] covariance Power.msg 表示电源状态，是否开启文件位置：自定义msg文件 Header header bool power ###################### bool ON = 1 bool OFF = 0 Twist.msg 定义空间中物体运动的线速度和角速度文件位置：geometry_msgs/Twist.msg Vector3 linear Vector3 angular TwistWithCovariance.msg 消息定义了包含不确定性的速度量，协方差矩阵按行分别表示：沿x方向速度的不确定性，沿y方向速度的不确定性，沿z方向速度的不确定性绕x转动角速度的不确定性，绕y轴转动的角速度的不确定性，绕z轴转动的角速度的不确定性文件位置：geometry_msgs/TwistWithCovariance.msg Twist twist float64[36] covariance #分别表示[x; y; z; Rx; Ry; Rz] Odometry.msg 消息描述了自由空间中位置和速度的估计值文件位置：nav_msgs/Odometry.msg Header header string child_frame_id PoseWithCovariance pose TwistWithCovariance twist © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-10 12:59:08 "},"Chapter3/service.html":{"url":"Chapter3/service.html","title":"第五篇 service服务","keywords":"","body":"service 服务 上一篇我们介绍了ROS的通信方式中的topic(主题)通信，我们知道topic是ROS中的一种单向的异步通信方式。然而有些时候单向的通信满足不了通信要求，比如当一些节点只是临时而非周期性的需要某些数据，如果用topic通信方式时就会消耗大量不必要的系统资源，造成系统的低效率高功耗。 这种情况下，就需要有另外一种请求-查询式的通信模型(C/S模型)。这节我们来介绍ROS通信中的另一种通信方式——service(服务)。 一、service工作原理 为了解决以上问题，service方式在通信模型上与topic做了区别。Service通信是双向的，它不仅可以发送消息，同时还会有反馈。所以service包括两部分，一部分是请求方（Client），另一部分是应答方/服务提供方（Server）。请求方（Client）发送一个request，要等待server处理，处理完成之后，server反馈回一个reply，这样通过类似“请求-应答”的机制完成整个服务通信。 这种通信方式的示意图如下： Node B是server（应答方），提供了一个服务的接口，叫做/Service，我们一般都会用string类型来指定service的名称，类似于topic。Node A向Node B发起请求，经过Node B处理后，Node A得到了反馈。 通信过程：Service是同步通信方式，所谓同步就是说： Node A发布请求后会在原地等待reply。 Node B处理完成之后，返回一个reply。 Node A继续执行。 Node A等待过程中，是处于阻塞状态的。这样的通信模型没有频繁的消息传递，没有冲突与高系统资源的占用，只有接受请求才执行服务，简单而且高效。 二、topic vs service 我们对比一下这两种最常用的通信方式，加深我们对两者的理解和认识，具体见下表： 名称 Topic Service 通信方式 异步通信 同步通信 实现原理 TCP/IP TCP/IP 通信模型 Publish-Subscribe Request-Reply 映射关系 Publish-Subscribe(多对多) Request-Reply（多对一） 特点 接受者收到数据会回调（Callback） 远程过程调用（RPC）服务器端的服务 应用场景 连续、高频的数据发布 低频(偶尔)使用的功能/具体的任务 举例 激光雷达、里程计发布数据 开关传感器、拍照、逆解计算 注意：远程过程调用(Remote Procedure Call，RPC),可以简单通俗的理解为在一个进程里调用另一个进程的函数。 　三、service操作命令 在实际应用中，service通信方式的命令时rosservice，具体的命令参数如下表： rosservice 命令 作用 rosservice list 显示服务列表 rosservice info 打印服务信息 rosservice type 打印服务类型 rosservice uri 打印服务ROSRPC uri rosservice find 按服务类型查找服务 rosservice call 使用所提供的args调用服务 rosservice args 打印服务参数 四、测试示例 首先依然是打开我们教材的模拟场景：roslaunch robot_sim_demo robot_spawn.launch。 输入rosservice list，查看当前运行的服务。 随机选择/gazebo/delete_light服务，观察名称，是删除光源的操作。 输入rosservice info /gazebo/delete_light查看属性信息。可以看到信息，Node：/gazebo，Type：gazebo_msgs/DeleteLight, Args：Light_name。这里的类型type也就是下文介绍的srv,传递参数Light_name 输入rosservice call /gazebo/delete_light sun,这里的sun 是参数名，使我们模拟场景中的唯一光源太阳。操作完成后可以看到场景中的光线消失。 前： 后： 可以看到终端的回传信息：success: True和sun successfully deleted。这就是双向通信的信息反馈，通知操作已经成功完成。 © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-10 17:42:36 "},"Chapter3/srv.html":{"url":"Chapter3/srv.html","title":"第六篇 srv文件","keywords":"","body":"srv文件 类似msg文件，srv文件是用来描述服务(service)数据类型的，service通信的数据格式就定义在*.srv格式的文件中。它声明了一个服务类型，包括请求(request)和响应（reply）两部分。其格式声明如下，举例： msgs_demo/srv/DetectHuman.srv bool start_detect #client请求服务格式 --- #分界线 my_pkg/HumanPose[] pose_data #server返回数据格式 msgs_demo/msg/HumanPose.msg std_msgs/Header header string uuid int32 number_of_joints my_pkg/JointPose[] joint_data msgs_demo/msg/JointPose.msg string joint_name geometry_msgs/Pose pose float32 confidence 以DetectHUman.srv文件为例，该服务例子取自OpenNI的人体检测ROS软件包。它是用来查询当前深度摄像头中的人体姿态和关节数的。srv文件格式很固定，第一行是请求的格式，中间用---隔开，第三行是应答的格式。在本例中，请求为是否开始检测，应答为一个数组，数组的每个元素为某个人的姿态（HumanPose）。而对于人的姿态，其实是一个msg，所以srv可以嵌套msg在其中，但它不能嵌套srv。 操作命令 具体的操作指令如下表： rossrv 命令 作用 rossrv show 显示服务描述 rossrv list 列出所有服务 rossrv md5 显示服务md5sum rossrv package 列出包中的服务 rossrv packages 列出包含服务的包 © 黄文庆 all right reserved，powered by Gitbook文件修订时间： 2020-05-10 18:05:04 "}}